/* -*-c++-*- */
/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph
* Copyright 2008-2012 Pelican Mapping
* http://osgearth.org
*
* osgEarth is free software; you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>
*/
#ifndef OSGEARTHSIM_SIMULATION_H
#define OSGEARTHSIM_SIMULATION_H 1

#include <osgEarthSim/Common>

#include <osgEarth/MapNode>
#include <osgEarthSim/EntityProvider>
#include <osgEarthSim/IconFactory>

#include <osgEarthAnnotation/TrackNode>


namespace osgEarth { namespace Sim {

    using namespace osgEarth::Annotation;


    class OSGEARTHSIM_EXPORT EntityRecord : public osg::Referenced
    {
    public:
        EntityRecord(TrackNode* trackNode, Entity_State_PDU* state);  

        ~EntityRecord();

        double getTime() const;

        void updateSimulation( );          

        Entity_State_PDU* getEntityState() const { return _state; }
        void setEntityState(Entity_State_PDU* state);
        
        TrackNode* getTrackNode() const { return _trackNode.get(); }

    private:
        double _time;
        osg::ref_ptr< TrackNode > _trackNode;
        Entity_State_PDU* _state;
    };

    struct EntityId
    {
        EntityId(int site, int application, int id):
         _site( site),
        _application(application),
        _id(id)
        {            
        }        

         bool operator < (const EntityId& rhs) const 
         {
             if (_site < rhs._site) return true;
             if (_site > rhs._site) return false;
             if (_application < rhs._application) return true;
             if (_application > rhs._application) return false;
             return _id < rhs._id;
         }

        int _site;
        int _application;
        int _id;
    };

    typedef std::map< EntityId, osg::ref_ptr< TrackNode > > TrackNodeMap;

    typedef std::map< EntityId, osg::ref_ptr< EntityRecord > > EntityRecords;


    /***************************************************************************/
    
    
    struct OSGEARTHSIM_EXPORT SimulationCallback : public osg::Referenced
    {
        virtual void onEntityStateChanged(EntityRecord const* record) { };
        
        virtual void onEntityAdded(EntityRecord const* record) { };
        
        virtual void onEntityRemoved(EntityRecord const* record) { };
        
        virtual ~SimulationCallback() { };
    };
    
    typedef std::list< osg::ref_ptr<SimulationCallback> > SimulationCallbackList;
    
    /***************************************************************************/

    class OSGEARTHSIM_EXPORT Simulation : public EntityCallback 
    {
    public:
        Simulation(MapNode* mapNode, osg::Group* entityGroup, EntityProvider* provider, IconFactory* iconFactory=0);

        virtual ~Simulation();

        virtual void onEntityStateChanged( Entity_State_PDU* entityState );          

        void updateSim();
        
        void setEntityTimeout(double seconds);
        
        void addSimulationCallback(SimulationCallback* cb);
        void removeSimulationCallback(SimulationCallback* cb);

    protected:

        void createFieldSchema( TrackNodeFieldSchema& schema );

        EntityRecords _entities;
        osg::ref_ptr< osg::Group > _entityGroup;
        osg::ref_ptr< MapNode > _mapNode;    
        OpenThreads::Mutex _mutex; 
        osg::ref_ptr< IconFactory > _iconFactory;
        SimulationCallbackList _simCallbacks;
        double _entityTimeout;
        osg::ref_ptr< EntityProvider> _provider;
    };

}}

#endif //OSGEARTHSIM_SIMULATION_H