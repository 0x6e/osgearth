/* -*-c++-*- */
/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph
* Copyright 2008-2010 Pelican Mapping
* http://osgearth.org
*
* osgEarth is free software; you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>
*/
#ifndef OSGEARTH_ANNOTATION_DRAW_STATE_H
#define OSGEARTH_ANNOTATION_DRAW_STATE_H 1

#include <osgEarthAnnotation/Common>
#include <osgUtil/CullVisitor>
#include <osg/Switch>

namespace osgEarth { namespace Annotation
{	
    using namespace osgEarth;

    template<typename T> struct TraverseFunctor {
        T* _target;
        TraverseFunctor(T* target) : _target(target) { }
        void operator()(osg::NodeVisitor& nv) { _target->T::traverse(nv); }
    };

    template<typename T>
    struct TraverseNode : public osg::Node {
        TraverseFunctor<T> _tf;
        TraverseNode(TraverseFunctor<T>& tf) : _tf(tf) { }
        void traverse(osg::NodeVisitor& nv) { _tf(nv); }
        osg::BoundingSphere computeBound() const { return _tf._target->getBound(); }
    };

    class /*no-export*/ DrawStateTechnique : public osg::Referenced
    {
    public:
        DrawStateTechnique() : _injectionAdded(false) { }

        virtual DrawStateTechnique* clone() const =0;

        virtual bool isShareable() const { return false; }

        virtual void preTraverse( osg::NodeVisitor& nv, osg::Group* parent ) { }

        virtual void postTraverse( osg::NodeVisitor& nv ) { }

        template<typename T> void traverse( osg::NodeVisitor& nv, TraverseFunctor<T>& tf ) { 
            if ( _injection.valid() ) {
                if ( !_injectionAdded ) {
                    _injection->addChild( new TraverseNode<T>(tf) );
                    _injectionAdded = true;
                }
                _injection->accept(nv);
            }
            else {
                tf(nv);
            }
        }

        osg::ref_ptr<osg::Group> _injection;
        bool                     _injectionAdded;
    };

    class OSGEARTHANNO_EXPORT ScaleDrawStateTechnique : public DrawStateTechnique
    {
    public:
        virtual bool isShareable() const { return false; }
        virtual DrawStateTechnique* clone() const { return new ScaleDrawStateTechnique(); }

        virtual void preTraverse( osg::NodeVisitor& nv, osg::Group* parent );
        virtual void postTraverse( osg::NodeVisitor& nv );
    };

    class OSGEARTHANNO_EXPORT OutlineDrawStateTechnique : public DrawStateTechnique
    {
    public:
        virtual bool isShareable() const { return true; }
        virtual DrawStateTechnique* clone() const { return new OutlineDrawStateTechnique(); }

        OutlineDrawStateTechnique();
    };

    class OSGEARTHANNO_EXPORT EncircleDrawStateTechnique : public DrawStateTechnique
    {
    public:
        EncircleDrawStateTechnique();

        virtual bool isShareable() const { return false; }
        virtual DrawStateTechnique* clone() const { return new EncircleDrawStateTechnique(); }

        virtual void preTraverse( osg::NodeVisitor& nv, osg::Group* parent );

    protected:
        osg::MatrixTransform* _xform;
    };

} } // namespace osgEarth::Annotation

#endif //OSGEARTH_ANNOTATION_DRAW_STATE_H
