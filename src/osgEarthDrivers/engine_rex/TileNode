/* -*-c++-*- */
/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph
* Copyright 2008-2014 Pelican Mapping
* http://osgearth.org
*
* osgEarth is free software; you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>
*/
#ifndef OSGEARTH_DRIVERS_REX_TERRAIN_ENGINE_TILE_NODE
#define OSGEARTH_DRIVERS_REX_TERRAIN_ENGINE_TILE_NODE 1

#include "Common"
#include "TileModel"
#include "RenderBindings"
#include "Loader"
#include <OpenThreads/Atomic>
#include <osgEarth/TerrainTileNode>
#include <vector>

namespace osgEarth { namespace Drivers { namespace RexTerrainEngine
{
    class TileGroupFactory;

    class TileData : public osg::Referenced
    {
    public:
        bool isReady() const;

        osg::Texture* getTexture() const;

        void bind(osg::StateSet* stateSet, osg::RefMatrix* matrix);

    protected:
        osg::ref_ptr<osg::Referenced> _request;
        osg::ref_ptr<osg::Texture>    _texture;
        osg::ref_ptr<TerrainRaster>   _raster;
    };

    typedef std::vector< osg::ref_ptr<TileData> > TileDataVector;


    /**
     * TileNode represents a single tile. TileNode has 5 children:
     * one SurfaceNode that renders the actual tile content under a MatrixTransform;
     * and four TileNodes representing the LOD+1 quadtree tiles under this tile.
     */
    class TileNode : public osg::Group
    {
    public:
        TileNode();

        /** TileKey of the key representing the data in this node. */
        const TileKey& getTileKey() const { return _key; }

        void setMapRevision(Revision rev) { } // nyi - check for need

        void setDirty(bool value);

        /** Renderable geometry for this tile node. */
        osg::Node* getPayload() const { return _payload.get(); }

        /** Creates the geometry and state for this tilenode. */
        void create(const TileKey& key, TileGroupFactory* context);

        /** Whether this node has enough data to traverse. */
        bool isReadyToTraverse() const;

        /** Whether the tile is expired; i.e. has not been visited in some time. */
        bool isDormant(osg::NodeVisitor& nv) const;

        /** Distance from camera to tile center at which we subdivide the tile into 4 subtiles. */
        float getSubdivideRange(osg::NodeVisitor& nv) const;

        /** Load (or continue loading) content for the tiles in this quad. */
        void load(osg::NodeVisitor& nv);

        /** Notifies this tile that another tile has come into existence. */
        void notifyOfArrival(TileNode* that) { } // nyi - todo

        /** Set inheritance matrices as necessary. Return true is changed were made. */
        bool inheritState(TileNode* parent, const RenderBindings& bindings);

        /** Returns the tile's parent; convenience function */
        TileNode* getParentTile() { return dynamic_cast<TileNode*>(getParent(0)); }

    public: // osg::Node

        osg::BoundingSphere computeBound() const;

        void traverse(osg::NodeVisitor& nv);

    protected:
        TileKey                            _key;
        osg::ref_ptr<osg::Node>            _payload;
        osg::observer_ptr<Loader::Request> _loadRequest;
        osg::observer_ptr<Loader::Request> _expireRequest;
        Threading::Mutex                   _mutex;
        bool                               _dirty;
        OpenThreads::Atomic                _lastTraversalFrame;

        TileNode* getSubTile(unsigned i) { return dynamic_cast<TileNode*>(getChild(i)); }

        void createChildren(osg::NodeVisitor& nv);

        void expireChildren(osg::NodeVisitor& nv);
    };

    typedef std::vector< osg::ref_ptr<TileNode> > TileNodeVector;

} } } // namespace osgEarth::Drivers::RexTerrainEngine

#endif // OSGEARTH_DRIVERS_REX_TERRAIN_ENGINE_TILE_NODE
