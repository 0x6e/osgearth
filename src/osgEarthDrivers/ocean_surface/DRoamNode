/* -*-c++-*- */
/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph
 * Copyright 2008-2010 Pelican Mapping
 * http://osgearth.org
 *
 * osgEarth is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */
#ifndef OSGEARTH_ENGINE_DROAM_MAPNODE_H
#define OSGEARTH_ENGINE_DROAM_MAPNODE_H 1

#include "MeshManager"
#include <osg/CoordinateSystemNode>
#include <osg/Geode>
#include <osg/NodeVisitor>
#include <osgEarth/Map>

using namespace osgEarth;

/**
 * D-ROAM: A diamond-based continuous manifold terrain engine.
 *
 * Initially based on the "diamond structure" concept found in:
 * "Realtime Optimal Adaptation for Planetary Geometry and Texture: 4-8 Tile Hierarchies"
 * by Hwa, Duchaineau, and Joy. [1]
 * http://www.computer.org/portal/web/csdl/doi/10.1109/TVCG.2005.65
 *
 * The global mesh is comprised of Diamonds. The mesh is primed with a "cube manifold" as
 * described in [1]. The entire mesh shared a single vertex array and a single
 * corresponding normal array (in VBOs). Each Diamond referenced verts in this array, thus
 * ensuring a worldwide, continuous, deformable mesh with no cracks.
 *
 * The first version of this engine rendered each Diamond at each level with its own primitive
 * set. This worked well, but left us with a problem-- no regular gridded structure on which to
 * easily map textures. The second version addresses this by only rendering "quadtree ancestor"
 * diamonds, i.e, diamonds at every other level (odd-numbered levels). By doing this, the base
 * quads correspond to the faces of the base cube manifold, and all sub-quads fall within these
 * 6 faces. We can then use osgEarth's Cube SRS to map textures directly to these quadtree
 * ancestor geometries.
 */
class DRoamNode : public osg::Group
{
public:
    /**
     * Constructs a new surface node.
     * @param map        Map to associate with this surface
     * @param maskLayer  Image layer to use for ocean masking (optional)
     * @param bathyLayer Bathymetric elevation layer to use for ocean masking
     */
    DRoamNode(
        Map*            map, 
        ImageLayer*     maskLayer  =0L,
        ElevationLayer* bathyLayer =0L );

public:
    virtual void traverse(osg::NodeVisitor& nv);

private:
    osg::ref_ptr<osg::Geode>     _geode;
    osg::ref_ptr<Manifold>      _manifold;
    osg::ref_ptr<MeshManager>    _mesh;
    osg::ref_ptr<Map>            _map;
    osg::ref_ptr<ImageLayer>     _maskLayer;
    osg::ref_ptr<ElevationLayer> _bathyLayer;
};

#endif // OSGEARTH_ENGINE_DROAM_MAPNODE_H
