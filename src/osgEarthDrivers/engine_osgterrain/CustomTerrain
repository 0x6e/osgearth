/* -*-c++-*- */
/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph
* Copyright 2008-2010 Pelican Mapping
* http://osgearth.org
*
* osgEarth is free software; you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>
*/
#ifndef OSGEARTH_ENGINE_OSGTERRAIN_VERSIONED_TERRAIN
#define OSGEARTH_ENGINE_OSGTERRAIN_VERSIONED_TERRAIN 1

#include "Common"
#include "OSGTileFactory"
#include <osgEarth/TaskService>
#include <osgEarth/Locators>
#include <osgEarth/Profile>
#include <osgEarth/TerrainOptions>
#include <osgEarth/Map>
#include <osgEarth/ThreadingUtils>
#include <osgTerrain/Terrain>
#include <osgTerrain/TerrainTile>
#include <list>
#include <queue>

class TileFactory; //MapEngine;
class CustomTerrain;
class CustomTile;

typedef std::list< osg::ref_ptr<osgTerrain::TerrainTile> > TerrainTileList;

/**
 * Callback object for linstening to terrain events.
 */
struct OSGEARTH_EXPORT TerrainCallback : public osg::Referenced
{
    virtual void onTerrainTilesUpdated( const TerrainTileList& tiles ) { }
};
typedef std::list< osg::ref_ptr<TerrainCallback> > TerrainCallbackList;


using namespace osgEarth;


// Please refer the refreshFamily() method for more info on this structure.
struct Relative {
    int getImageLOD(unsigned int layerID)
    {
        LayerIDtoLODMap::iterator itr = imageLODs.find(layerID);
        if (itr != imageLODs.end()) return itr->second;
        return -1;
    }

    bool expected;
    int elevLOD;
    //int imageryLOD;
    typedef std::map<unsigned int, int> LayerIDtoLODMap;
    LayerIDtoLODMap imageLODs;
    osgTerrain::TileID tileID;
};

// Records a tile change request so that we can update tiles piecemeal
struct TileUpdate
{
    enum Action {
        UPDATE_IMAGE_LAYER, // requires index
        UPDATE_ALL_IMAGE_LAYERS,
        UPDATE_ELEVATION,
        UPDATE_ALL
    };

    TileUpdate( Action action, int index =-1 )
        : _action(action), _index(index) { }

    Action getAction() const { return _action; }
    int getIndex() const { return _index; }

private:
    Action _action;
    int _index;
};


/**
 * An OSG terrain tile that supports change detection.
 *
 * A CustomTile tracks a "terrain revision" number. If the terrian revision differs
 * from the parent Terrain's revision, that measn the tile is obselete and needs to
 * be regenerated or updates. 
 *
 * The CustomTile also maintains a Tile Revision number. Every change to the data in the
 * tile itself warrants a new revision number. This way, external processes that rely
 * on the contents of a Tile can detect changes.
 *
 * Note: the terrain revision and the tile revision are unrelated!
 */
class CustomTile : public osgTerrain::TerrainTile
{
public:
    CustomTile( const TileKey& key, GeoLocator* keyLocator, bool quickReleaseGLObjects );

    virtual const char* libraryName() const { return "osgEarth"; }
    virtual const char* className() const { return "CustomTile"; }


    /** Gets the tilekey associated with this tile. */
    const TileKey& getKey() const;

    /** Gets the locator associated with this tile. */

    /** Sets whether to use the TaskService to schedule per-layer background data loading. */
    void setUseLayerRequests( bool );
    bool getUseLayerRequests() const { return _useLayerRequests; }

    /** Sets whether to update the tile layer by layer vs. rebuidling the entire tile. */
    void setUsePerLayerUpdates( bool );

    /**
     * Gets the terrain revision that this tile is in sync with.
     */
    int getTerrainRevision() const;

    /**
     * Sets the terrain revision that this tile is in sync with.
     */
    void setTerrainRevision( int revision );

    /**
     * Returns true if this tile is in sync with its parent Terrain (i.e., their
     * version numbers are equal).
     */
    bool isInSyncWithTerrain() const;

    /**
     * Bumps this tile's revision number.
     */
    void incrementTileRevision();

    /**
     * Gets this tile's revision number.
     */
    int getTileRevision() const;

    /** Updates and services this tile's service pending requests. */
    void servicePendingImageRequests( const MapFrame& mapf, int stamp );

    void servicePendingElevationRequests( const MapFrame& mapf, int stamp, bool tileTableLocked );

    // returns TRUE if the tile was modified as a result of a completed request.
    bool serviceCompletedRequests( const MapFrame& mapf, bool tileTableLocked );

    /** Setting this hint tells the tile whether it should bother trying to load elevation data. */
    void setHasElevationHint( bool hasElevation );

    /** Gets whether the tile's real (not placeholder) elevation data has been loaded. */
    bool isElevationLayerUpToDate() const;

    /** Gets or sets the LOD of this tile's current heightfield data. */
    int getElevationLOD() const;
    void setElevationLOD( int lod );

    /** Gets the terrain object to which this tile belongs. */
    class CustomTerrain* getCustomTerrain();
    const class CustomTerrain* getCustomTerrain() const;

    bool getHasBeenTraversed() const;

    Threading::ReadWriteMutex& getTileLayersMutex();

    bool cancelRequests();

    void updateImagery( unsigned int layerId, const MapFrame& mapf, OSGTileFactory* factory );

    bool getUseTileGenRequest() const;

    Relative* getFamily();

    // marks a request to regenerate the tile based on the specified change(s).
    void queueTileUpdate( TileUpdate::Action action, int index =-1 );

    void resetElevationRequests( const MapFrame& mapf );

    float getVerticalScale() const;
    void setVerticalScale(float verticalScale);


public: // OVERRIDES

    virtual void traverse( class osg::NodeVisitor& nv );

    /** If State is non-zero, this function releases any associated OpenGL objects for
    * the specified graphics context. Otherwise, releases OpenGL objects
    * for all graphics contexts. */
    virtual void releaseGLObjects(osg::State* = 0) const;

    virtual osg::BoundingSphere computeBound() const;

protected:

    ~CustomTile();


private:
    int  _terrainRevision;
    int  _tileRevision;
    bool _useLayerRequests;
    bool _requestsInstalled;
    bool _usePerLayerUpdates;
    bool _hasElevation;
    bool _elevationLayerDirty;
    bool _colorLayersDirty;
    bool _elevationLayerRequested;
    bool _elevationLayerUpToDate;
    int  _elevationLOD;
    bool _hasBeenTraversed;
    bool _useTileGenRequest;
    bool _sequentialImagery;
    bool _quickReleaseGLObjects;

    typedef std::queue<TileUpdate> TileUpdateQueue;
    TileUpdateQueue _tileUpdates;

    TileKey _key;
    osg::ref_ptr<GeoLocator> _keyLocator;
    TaskRequestList _requests;
    osg::ref_ptr<TaskRequest> _elevRequest;
    osg::ref_ptr<TaskRequest> _elevPlaceholderRequest;
    osg::ref_ptr<TaskRequest> _tileGenRequest;

    osg::observer_ptr<CustomTerrain> _CustomTerrain;

    Relative _family[5];
    Threading::ReadWriteMutex _tileLayersMutex;

    /** Deals with completed requests during the UPDATE traversal. */
    void installRequests( const MapFrame& mapf, int stamp );
    bool readyForNewElevation();
    bool readyForNewImagery(osgEarth::ImageLayer* layer, int currentLOD);

    float _verticalScale;

public:
    void adjustUpdateTraversalCount( int delta );
};


/**
 * An osgTerrain derivation that tracks a revision number. When the revision number
 * changes, this incidates to member tiles that something substantial (like the 
 * map model) has changed and that they need to regenreate, update, or otherwise
 * accomodate the change.
 *
 * Individual tiles have their own Revision numbers, which are unrelated. These
 * change with every change to the physical tile.
 */
class CustomTerrain : public osgTerrain::Terrain
{
public:
    CustomTerrain(
        const MapFrame& update_mapf,
        const MapFrame& cull_mapf,
        OSGTileFactory* factory,
        bool quickReleaseGLObjects );

    virtual const char* libraryName() const { return "osgEarth"; }
    virtual const char* className() const { return "CustomTerrain"; }

public:
    /**
     * Bumps the version number up by one. Versioned Tiles attached to this
     * terrain will detect the mismatch and regenerate themselves.
     */
    void incrementRevision();

    /**
     * Gets the current terrain configuration revision.
     */
    int getRevision() const;

    OSGTileFactory* getTileFactory();
    bool getQuickReleaseGLObjects() const { return _quickReleaseGLObjects; }

    TaskService* getImageryTaskService(int layerId);
    TaskService* getElevationTaskService();
    TaskService* getTileGenerationTaskSerivce();

    const MapFrame& getUpdateThreadMapFrame() { return _update_mapf; }
    const MapFrame& getCullThreadMapFrame() { return _cull_mapf; }

    /**
     * Gets the total number of tasks remaining in all of the TaskServices this CustomTerrain is managing
     */
    unsigned int getNumTasksRemaining() const;

    virtual void traverse( osg::NodeVisitor &nv );

    /**
     * Updates the catalog of task service threads - this gets called by the OSGTerrainEngine
     * in response to a change in the Map's data model. The map frame is that of the terrain
     * engine.
     */
    void updateTaskServiceThreads( const MapFrame& mapf );

    bool updateBudgetRemaining() const;

    void addTerrainCallback( TerrainCallback* cb );

protected:

	~CustomTerrain();

    typedef std::map< osgTerrain::TileID, osg::ref_ptr<CustomTile> > TileTable;
    typedef std::queue< osg::ref_ptr<CustomTile> > TileQueue;
    typedef std::list< osg::ref_ptr<CustomTile> > TileList;
    typedef std::vector< osg::ref_ptr<CustomTile> > TileVector;
    typedef std::queue< osgTerrain::TileID > TileIDQueue;

    Threading::ReadWriteMutex _tilesMutex;
    TileTable  _tiles;
    TileList   _tilesToShutDown;
    TileQueue  _tilesToRelease;
    TileQueue  _tilesToAdd;
    TileVector _tilesToServiceElevation;

public:
    void releaseGLObjectsForTiles(osg::State*);

    void registerTile( CustomTile* newTile );

    void getCustomTile( const osgTerrain::TileID& id, osg::ref_ptr<CustomTile>& out_tile, bool lock =true );
    void getCustomTiles( TileList& out_tiles );
    void getTerrainTiles( TerrainTileList& out_tiles );

    const LoadingPolicy& getLoadingPolicy() const;

private:

    TaskService* createTaskService( const std::string& name, int id, int numThreads );
    TaskService* getTaskService( int id );

    void refreshFamily( 
        const MapInfo& info, const osgTerrain::TileID& tileId, Relative* family, bool tileTableLocked );

    int _revision; 
    OpenThreads::Mutex _revisionMutex;

    //osg::ref_ptr<Map> _map;

    osg::ref_ptr<OSGTileFactory> _tileFactory; // _engine;
    typedef std::map< int, osg::ref_ptr< TaskService > > TaskServiceMap;
    TaskServiceMap _taskServices;

    osg::ref_ptr<const Profile> _profile;
    OpenThreads::Mutex _taskServiceMutex;

    int _numLoadingThreads;
    int _onDemandDelay; // #frames

	bool _registeredWithReleaseGLCallback;
    TerrainCallbackList _terrainCallbacks;

    LoadingPolicy _loadingPolicy;

    // store a separate map frame for each of the traversal threads
    const MapFrame& _update_mapf; // map frame for the main/update traversal thread
    const MapFrame& _cull_mapf;   // map frame for the cull traversal thread

    bool _quickReleaseGLObjects;
    bool _quickReleaseCallbackInstalled;
};

#endif // OSGEARTH_ENGINE_OSGTERRAIN_VERSIONED_TERRAIN
