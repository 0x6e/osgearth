/* -*-c++-*- */
/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph
 * Copyright 2008-2010 Pelican Mapping
 * http://osgearth.org
 *
 * osgEarth is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */
#ifndef OSGEARTHQT_LOSCREATIONDIALOG_H
#define OSGEARTHQT_LOSCREATIONDIALOG_H 1

#include "ui_LOSCreationDialog.h"

#include <osgEarthQt/Common>
#include <osgEarthQt/DataManager>

#include <osgEarthAnnotation/Draggers>

#include <osg/AutoTransform>

#include <QDialog>

namespace osgEarth { namespace QtGui 
{
  class LOSIntersectingDragger : public osgEarth::Annotation::IntersectingDragger
  {
  public:
    LOSIntersectingDragger():
      osgEarth::Annotation::IntersectingDragger()
    {
      setLineColor(osg::Vec4(1.0f, 1.0f, 0.0f, 0.0f));
    }

    void setupDefaultGeometry()
    {
      // draw a line from ground to location
      _lineGeometry = new osg::Geometry;
      _lineVerts = new osg::Vec3Array();
      _lineVerts->reserve(2);
      _lineGeometry->setVertexArray( _lineVerts );

      osg::Vec4Array* colors = new osg::Vec4Array();
      colors->reserve( 2 );
      _lineGeometry->setColorArray( colors );
      _lineGeometry->setColorBinding(osg::Geometry::BIND_PER_VERTEX);

      _lineVerts->push_back( osg::Vec3d(0.0, 0.0, 0.0) );
      _lineVerts->push_back( osg::Vec3d(0.0, 0.0, _heightAboveTerrain * -1.0) );
      colors->push_back( _lineColor );
      colors->push_back( _lineColor );

      _lineGeometry->addPrimitiveSet( new osg::DrawArrays( GL_LINES, 0, _lineVerts->size()) );
      osg::Geode* lineGeode = new osg::Geode();
      lineGeode->addDrawable( _lineGeometry );
      lineGeode->getOrCreateStateSet()->setMode(GL_DEPTH_TEST, osg::StateAttribute::OFF);
      lineGeode->getOrCreateStateSet()->setMode(GL_LIGHTING, osg::StateAttribute::OFF);
      addChild( lineGeode );


      // draw a sphere at location
      osg::Sphere* shape = new osg::Sphere(osg::Vec3(0,0,0), _size);   
      osg::Geode* geode = new osg::Geode();
      _shapeDrawable = new osg::ShapeDrawable( shape );    
      geode->addDrawable( _shapeDrawable.get() );
      setDrawableColor( _color );

      geode->getOrCreateStateSet()->setMode(GL_DEPTH_TEST, osg::StateAttribute::OFF);
      geode->getOrCreateStateSet()->setMode(GL_LIGHTING, osg::StateAttribute::OFF);
      osg::AutoTransform* at = new osg::AutoTransform;
      at->setAutoScaleToScreen( true );
      at->addChild( geode );
      addChild( at );
    }

    void setHeightAboveTerrain( double hat )
    {
      _heightAboveTerrain = hat;
      (*_lineVerts)[1].set(0.0, 0.0, _heightAboveTerrain * -1.0);
      if (_lineGeometry.valid())
        _lineGeometry->dirtyDisplayList();
    }

    void setLineColor(const osg::Vec4& color) { _lineColor = color; }

  private:
    double _offset;
    osg::Vec4 _lineColor;
    osg::ref_ptr<osg::Geometry> _lineGeometry;
    osg::ref_ptr<osg::Vec3Array> _lineVerts;
  };

  //---------------------------------------------------------------------------

  class LOSCreationDialog : public QDialog
  {
  Q_OBJECT

  public:
    enum LOSPoint { P2P_START, P2P_END, RADIAL_CENTER };

    LOSCreationDialog(osgEarth::MapNode* mapNode, osg::Group* root, int losCount, DataManager* manager=0L, ViewVector* views=0L);

    osg::Group* losNode() { return _node.get(); }
    QString losName() { return _ui.nameBox->text(); }
    osg::Group* losEditor() { return _editor.get(); }

    void getLOSPoint(LOSPoint point, osg::Vec3d& out_point, bool relative=false);
    void setLOSPoint(LOSPoint point, const osg::Vec3d& value);

    bool isAltitudeRelative(LOSPoint point);

    void mapClick(const osg::Vec3d& point);

  public slots:
    void accept();
    void reject();
		
  private slots:
    void onP1TypeChange(const QString& text);
    void onP2TypeChange(const QString& text);
    void onRadTypeChange(const QString& text);

    void onP1MapButtonClicked(bool checked);
    void onP2MapButtonClicked(bool checked);
    void onRadMapButtonClicked(bool checked);

    void onP1FindNodeButtonClicked(bool checked);
    void onP2FindNodeButtonClicked(bool checked);
    void onRadFindNodeButtonClicked(bool checked);

    void onLocationValueChanged(double d);

    void onCurrentTabChanged(int index);

  protected:
    void closeEvent(QCloseEvent* event);

  private:
    void initUi(int losCount);
    bool doClose();
    void cleanupDraggers();
    void centerMapOnNode(osg::Node* node);
    void updateDragger(osgEarth::Annotation::IntersectingDragger* dragger, const osg::Vec3d& point);
    void updateP1Fields(double lat, double lon, double alt);
    void updateP2Fields(double lat, double lon, double alt);
    void updateRadFields(double lat, double lon, double alt);

    Ui::LOSCreationDialog _ui;
    osg::ref_ptr<osg::Group> _node;
    osg::ref_ptr<osg::Group> _editor;
    osg::ref_ptr<osgEarth::MapNode> _mapNode;
    osg::ref_ptr<osg::Group> _root;
    osg::ref_ptr<DataManager> _manager;
    osg::ref_ptr<osgEarth::Map> _map;
    osg::ref_ptr<LOSIntersectingDragger> _p1Dragger;
    osg::ref_ptr<LOSIntersectingDragger> _p2Dragger;
    osg::ref_ptr<LOSIntersectingDragger> _radDragger;
    bool _updatingUi;
    double _p1BaseAlt;
    double _p2BaseAlt;
    double _radBaseAlt;
    AnnotationVector _annotations;
    ViewVector* _views;

    QPushButton* _activeButton;
  };
} }

#endif // OSGEARTHQT_LOSCREATIONDIALOG_H
