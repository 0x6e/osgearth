/* -*-c++-*- */
/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph
 * Copyright 2008-2014 Pelican Mapping
 * http://osgearth.org
 *
 * osgEarth is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */

#ifndef OSGEARTHFEATURES_FEATURE_SOURCE_INDEX_NODE_H
#define OSGEARTHFEATURES_FEATURE_SOURCE_INDEX_NODE_H 1

#include <osgEarthFeatures/Common>
#include <osgEarthFeatures/FeatureDrawSet>
#include <osgEarthFeatures/FeatureSource>
#include <osg/Config>
#include <osg/Group>
#include <osg/Drawable>
#include <osgGA/GUIEventHandler>

namespace osgEarth { namespace Features
{
    /**
     * Options for a feature index
     */
    class OSGEARTHFEATURES_EXPORT FeatureSourceIndexOptions
    {
    public:
        FeatureSourceIndexOptions(const Config& conf =Config());

        /** Wheter to embed the actual Feature objects in the index (instead of
         *  just the FeatureID). This is useful for feature sources that cannot
         *  be queried by ID (e.g., streaming data like TFS) */
        optional<bool>& embedFeatures() { return _embedFeatures; }
        const optional<bool>& embedFeatures() const { return _embedFeatures; }

    public:
        Config getConfig() const;

    private:
        optional<bool> _embedFeatures;
    };


    /**
     * Interface for feature indexing.
     */
    class FeatureSourceIndex
    {
    public: // tagging functions
        virtual void tagDrawable(osg::Drawable* drawable, const Feature* feature) const =0;

        virtual void tagAllDrawables(osg::Node* node, const Feature* feature) const =0;

        virtual void tagNode(osg::Node* node, const Feature* feature) const =0;

        virtual ~FeatureSourceIndex() { }
    };
    

    /**
     * Picks features.
     */
    class OSGEARTHFEATURES_EXPORT FeaturePicker : public osgGA::GUIEventHandler
    {
    public:
        struct Callback : public osg::Referenced
        {
            virtual void onPick(const std::set<FeatureID>& results) = 0;
        };

        void setCallback(Callback* callback) { _callback = callback; }

    public:
        FeaturePicker();

        virtual ~FeaturePicker() { }

        void setPickGraph(osg::Node* graph);

    public: // osgGA::GUIEventHandler

        virtual bool handle(const osgGA::GUIEventAdapter& ea, osgGA::GUIActionAdapter& aa);

    protected:
        
        void pick(const osgGA::GUIEventAdapter& ea, osgGA::GUIActionAdapter& aa);

        void checkForPickResults();

        osg::ref_ptr<osg::Camera>    _camera;
        osg::ref_ptr<osg::Image>     _image;
        osg::observer_ptr<osg::Node> _graph;
        osg::ref_ptr<Callback>       _callback;
        bool                         _pickInProgress;
    };


    /**
     * Maintains an index that maps FeatureID's from a FeatureSource to
     * PrimitiveSets within the subgraph's geometry.
     */
    class OSGEARTHFEATURES_EXPORT FeatureSourceIndexNode : public osg::Group,
                                                           public FeatureSourceIndex
    {
    public:
        /** The attribute location for FID vertex tags. */
        static const int IndexAttrLocation;

    public:
        /**
         * Constructs a new index node.
         */
        FeatureSourceIndexNode(
            FeatureSource*                   featureSource,
            const FeatureSourceIndexOptions& options );

        /**
         * Destructor 
         */
        virtual ~FeatureSourceIndexNode();


    public: // FeatureSourceIndex

        /**
         * Associates a Drawable with a Feature.
         */
        void tagDrawable(osg::Drawable* drawable, const Feature* feature) const;

        /**
         * Finds all the Drawables user a node, and associates each one with the
         * specified feature.
         */
        void tagAllDrawables(osg::Node* node, const Feature* feature) const;

        /**
         * Associates a node with a Feature. This method does NOT tag the underlying
         * drawables; it just tags the node itself. So shader code that accesses the
         * FeatureID attribute array will not function when using this approach.
         */
        void tagNode(osg::Node* node, const Feature* feature) const;


    public:
        /**
         * The feature source tied to this node 
         */
        FeatureSource* getFeatureSource() { return _featureSource.get(); }

        /**
         * Traverses this node's subgraph and rebuilds the feature index based on
         * any tagged drawables found. (See tagGeometry for tagging drawables).
         */
        void reindex();

        /**
         * Gets a collection of all feature IDs tracked by this index.
         * @param output Container to populate with all FIDs.
         */
        bool getAllFIDs(std::vector<FeatureID>& output) const;

        /**
         * Gets the Feature ID corresponding a particular vertex in a Drawable.
         * This is primarily useful when processing the results of an intersector test.
         *
         * @param drawable       Drawable for which to lookup the feature ID
         * @param primitiveIndex Index of the primitive to look up
         * @param output         Holds the result of the query, if returning true
         * @return true if successful
         */
        bool getFID(osg::Drawable* drawable, int vertIndex, FeatureID& output) const;

        /**
         * Given a FeatureID, returns the collection of drawable/primitiveset combinations
         * corresponding to that feature.
         *
         * @param fid Feature ID to look up
         * @return Corresponding collection of primitive sets (empty if the query fails)
         */
        FeatureDrawSet& getDrawSet( const FeatureID& fid );

        /**
         * Given a FeatureID, returns the cached feature.
         *
         * @param fid     Feature ID to look up
         * @param output  cached feature 
         * @return true if successful 
         */
        bool getFeature(const FeatureID& fid, const Feature*& output) const;

    private:
        osg::ref_ptr<FeatureSource> _featureSource;

        typedef std::map<FeatureID, FeatureDrawSet> FeatureIDDrawSetMap;
        FeatureIDDrawSetMap _drawSets;

        struct Collect : public osg::NodeVisitor {
            Collect(FeatureIDDrawSetMap&, int);
            void apply(osg::Node&);
            void apply(osg::Geode&);
            FeatureIDDrawSetMap& _index;
            unsigned _psets;
            int _idAttrArraySlot;
        };
        
        FeatureSourceIndexOptions _options;

        // optionally embedded features; only populated when _options.embedFeatures = true
        typedef std::map< FeatureID, osg::ref_ptr<const Feature> > FeatureMap;
        mutable FeatureMap _features;

        int _idAttrArraySlot;

    public:
        virtual const char* className() const { return "FeatureSourceIndexNode"; }
        virtual const char* libraryName() const { return "osgEarthFeatures"; }
    };

} } // namespace osgEarth::Features

#endif // OSGEARTHFEATURES_FEATURE_SOURCE_INDEX_NODE_H
