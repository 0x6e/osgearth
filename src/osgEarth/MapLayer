/* -*-c++-*- */
/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph
 * Copyright 2008-2009 Pelican Ventures, Inc.
 * http://osgearth.org
 *
 * osgEarth is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */

#ifndef OSGEARTH_MAP_LAYER_H
#define OSGEARTH_MAP_LAYER_H 1

#include <osgEarth/Common>
#include <osgEarth/Config>
#include <osgEarth/TileSource>
#include <osgEarth/Profile>
#include <osgEarth/Caching>
#include <osgEarth/TaskService>
#include <osgEarth/DriverOptions>
#include <map>
#include <utility>
#include <queue>
#include <OpenThreads/Mutex>

namespace osgEarth
{
    /**
     * One layer in the map.
     */
    class OSGEARTH_EXPORT MapLayer : public osg::Referenced
    {
    public:
        /**
         * Map layer data types.
         */
        enum Type {
            TYPE_IMAGE,
            TYPE_HEIGHTFIELD
        };

    public: //ctors

        /**
         * Constructs a new map layer with the specified driver options.
         */
        MapLayer(
            const std::string& name,
            Type type,
            const DriverOptions* options );

        /**
         * Constructs a new map layer based on information in a Config object. This is
         * the typical method for creating a layer from a serialized definition (like
         * the .earth file).
         */
        MapLayer(
            Type type,
            const Config& driverConf );

        /**
         * Constructs a new map layer with a user-provided TileSource driver.
         */
        MapLayer(
            const std::string& name,
            Type type,
            TileSource* driver );

    public: // deprecated ctors

        // deprecated- for backwards compatibility only.
        MapLayer(
            const std::string& name,
            Type type,
            const std::string& driver,
            const Config& driverConf = Config() );

        // for backwards compatibility only. use the version above from now on.
        MapLayer(
            const std::string& name,
            Type type,
            const std::string& driver,
            const Properties& props );


    public: // properties

        /**
         * Gets the unique ID of this map layer
         */
        unsigned int getId() const;

        /**
         * Gets the readable name of the map layer.
         */
        const std::string& getName() const;

        /**
         * Gets the layer type of the map layer.
         */
        const Type& getType() const;

        /**
         * Gets the name of the driver to use to create this map layer's TileSource engine.
         */
        const std::string& getDriver() const;

        /**
         * Gets the name/value properties for configuration of the driver.
         */
        const Config& getDriverConfig() const;

        /**
         * Gets the driver options used to create this layer.
         */
        const DriverOptions* getDriverOptions() const {
            return _driverOptions.get(); }

		/**
		 * Gets the profile of this MapLayer
		 */
		const Profile* getProfile() const;

        /**
         * Gets the underlying TileSource engine that serves this map layer. Use with caution.
         */
        TileSource* getTileSource() const;

    public: // properties

        /**
         * Gets the explicit profile setup for this map layer. By default, the layer will 
         * try to automatically determine the Profile from the tile source. This property
         * sets it explicitly instead.
         */
        optional<ProfileConfig>& profileConfig();
        const optional<ProfileConfig>& profileConfig() const;

        /**
         * Gets or sets the minimum level of detail for which this layer should generate data.
         */
        optional<int>& minLevel();
        const optional<int>& minLevel() const;

        /**
         * Gets or sets the maximum level of detail for which this layer should generate data.
         */
        optional<int>& maxLevel();
        const optional<int>& maxLevel() const;

		/**
		 * Gets the opacity of this MapLayer
		 */
		float getOpacity() const;

		/*
		 * Sets the opacity of this MapLayer
		 */
		void setOpacity(float opacity);

		/**
		 * Gets whether this MapLayer is enabled or not
		 */
		bool getEnabled() const;

		/**
		 * Sets whether this MapLayer is enabled or not.
		 */
		void setEnabled(bool enabled);

		/**
		 * Gets or sets the nodata image for this MapLayer
		 */
		optional<std::string>& noDataImageFilename();
		const optional<std::string>& noDataImageFilename() const;

		/**
		 * Gets the transparent color of this TileSource
		 */
		const optional<osg::Vec4ub>& transparentColor() const;
		optional<osg::Vec4ub>& transparentColor();

		/**
		 * Gets whether or not to allow the creation of Mercator images for Geographic scenes
		 */
        optional<bool>& useMercatorFastPath() { return _useMercatorFastPath; }
        const optional<bool>& useMercatorFastPath() const { return _useMercatorFastPath; }

		/**
		 * Gets whether to use exact cropping if image cropping is necessary
		 */
		bool getExactCropping() const { return _exactCropping; } 

		/**
		 * Sets whether to use exact cropping if image cropping is necessary
		 */
		void setExactCropping( bool exactCropping ) { _exactCropping = exactCropping; }
		/**
		 * Gets the desired tile size to reproject imagery to if necessary.
		 */
		unsigned int getReprojectedTileSize() const { return _reprojected_tile_size; }

		/**
		 * Sets the desired tile size to reproject imagery to if it is necessary.
		 * If set to 0, osgEarth will attempt to maintain a consistent resolution for the tiles.
		 */
		void setReprojectedTileSize( unsigned int tile_size) { _reprojected_tile_size = tile_size;}

		/**
		 * The format that this MapLayer should use when caching.
		 */
        optional<std::string>& cacheFormat() { return _cacheFormat; }
        const optional<std::string>& cacheFormat() const { return _cacheFormat; }

        /**
         * Whether to cache this layer or not.
         */
        optional<bool>& cacheEnabled() { return _cacheEnabled; }
        const optional<bool>& cacheEnabled() const { return _cacheEnabled; }

		/**
		 * Whether to try to run this MapLayer strictly from the cache only.
		 */
        optional<bool>& cacheOnly() { return _cacheOnly; }
        const optional<bool>& cacheOnly() const { return _cacheOnly; }
        
        /**
         * The loading weight of this MapLayer (for threaded loading policies).
         */
        optional<float> loadingWeight() { return _loadingWeight; }
        const optional<float>& loadingWeight() const { return _loadingWeight; }

    public: // methods

		/**
		 *Gets whether the given key is valid for this MapLayer
		 */
		bool isKeyValid(const TileKey* key) const;

		/**
		 * Creates a GeoImage from this MapLayer
		 */
		GeoImage* createImage( const TileKey* key,
                               ProgressCallback* progress = 0);

        /**
         * Creates a GeoHeightField for this MapLayer.
         * The returned HeightField will always match the geospatial extents of the incoming TileKey.
         */
        osg::HeightField* createHeightField( const TileKey* key,
                                             ProgressCallback* progress = 0);

		 /**
         * Gets the user-provided options structure stored in this map.
         */
        const osgDB::ReaderWriter::Options* getGlobalOptions() const;

        void setGlobalOptions( const osgDB::ReaderWriter::Options* options );

		/**
         * Gets the reference URI. See setReferenceURI for more info.
         */
        const std::string& getReferenceURI() const;

        /**
         * Sets a reference URI. Usually this is the location of a file from which this map
         * was created. This acts as a reference point for any relative paths/URIS that may
         * occur elsewhere in the configuration.
         *
         * Note: Set this before adding any layers to the map.
         */
        void setReferenceURI( const std::string& uri );


		/**
		 * Gets the Cache to be used on this MapLayer.
		 */
		Cache* getCache() const;

		/**
		 * Sets the cache to be used on this MapLayer
		 */
		void setCache( Cache* cache );

        /**
         * Suggests a cache format for this layer
         */
        std::string suggestCacheFormat() const;

        
        virtual Config toConfig() const;

    protected:

		void initTileSource();

		osg::Image* createImageWrapper( const TileKey* key,
                                        bool cacheInLayerProfile,
                                        ProgressCallback* progress );
		GeoHeightField* createGeoHeightField( const TileKey* key,
                                              ProgressCallback* progress);

		void readEnvironmentalVariables();

        ~MapLayer() { }

    private:
        unsigned int _id;
        std::string _name;
        Type        _type;
        std::string _driver;
        Config      _driverConf;
        osg::ref_ptr<const DriverOptions> _driverOptions;

       
        optional<ProfileConfig> _profileConf;
        optional<int> _minLevel;
        optional<int> _maxLevel;
	    optional<std::string> _nodata_image_filename;
		optional<osg::Vec4ub> _transparentColor;
        optional<bool> _useMercatorFastPath;
		optional<std::string> _cacheFormat;
        optional<bool> _cacheEnabled;
		optional<bool> _cacheOnly;
        optional<float> _loadingWeight;

        bool _exactCropping;
		bool _cacheOnlyEnv;
		float _opacity;
		bool _enabled;

        
        osg::ref_ptr<TileSource> _tileSource;
		osg::ref_ptr<Cache> _cache;
	    osg::ref_ptr<osg::Image> _nodata_image;


		std::string _referenceURI;

		unsigned int _reprojected_tile_size;

		osg::ref_ptr<const osgDB::ReaderWriter::Options> _globalOptions;

		osg::ref_ptr< const Profile > _profile;

        osg::ref_ptr< const Profile > _cacheProfile;

        OpenThreads::Mutex _initMutex;
    };

    /**
     * Convenience class that automatically sets the TYPE_IMAGE layer type.
     */
    class OSGEARTH_EXPORT ImageMapLayer : public MapLayer
    {
    public:
        ImageMapLayer( const std::string& name, const DriverOptions* options ) :
          MapLayer( name, MapLayer::TYPE_IMAGE, options ) { }
        
        ImageMapLayer( const std::string& name, TileSource* source ) :
          MapLayer( name, MapLayer::TYPE_IMAGE, source ) { }
    };
    
    class OSGEARTH_EXPORT HeightFieldMapLayer : public MapLayer
    {
    public:
        HeightFieldMapLayer( const std::string& name, const DriverOptions* options ) :
          MapLayer( name, MapLayer::TYPE_HEIGHTFIELD, options ) { }
        
        HeightFieldMapLayer( const std::string& name, TileSource* source ) :
          MapLayer( name, MapLayer::TYPE_HEIGHTFIELD, source ) { }
    };


    typedef std::vector< osg::ref_ptr<MapLayer> > MapLayerList;

	class TransparentLayer : public osgTerrain::ImageLayer
	{
	public:
		TransparentLayer(osg::Image* image, MapLayer* mapLayer):
			osgTerrain::ImageLayer(image),
		    _mapLayer(mapLayer),
            _lod(-1)
		{
		}

        unsigned int getId() const
        {
            return _mapLayer->getId();
        }

		float getOpacity() const
		{
			return _mapLayer->getOpacity();
		}

		bool getEnabled() const
		{
			return _mapLayer->getEnabled();
		}

        int getLevelOfDetail() const
        {
            return _lod;
        }

        void setLevelOfDetail(int lod)
        {
            _lod = lod;
        }

		osg::ref_ptr<MapLayer> _mapLayer;
        int _lod;
	};


    class L2Cache
    {
    public:
        L2Cache();
        GeoImage* createImage( MapLayer* layer, const TileKey* key );
        osg::HeightField* createHeightField( MapLayer* layer, const TileKey* key );
    public:
        typedef std::pair<MapLayer*,std::string> TileTag;
        typedef std::map<TileTag,osg::ref_ptr<osg::Referenced> > TileMap;
        typedef std::queue<TileTag> TileTagQueue;
        struct TileCache {
            TileCache() : _hits(0), _misses(0) { }
            TileMap _map;
            TileTagQueue _fifo;
            OpenThreads::Mutex _mutex;
            void put(const TileTag& tag, osg::Referenced* obj);
            osg::Referenced* get(const TileTag& tag);
            int _hits, _misses;
        };

    protected:
        TileCache _cache;
        TaskService* _service;
        void scheduleSubKeys(MapLayer*,const TileKey*);
    };
}

#endif // OSGEARTH_MAP_LAYER_H
