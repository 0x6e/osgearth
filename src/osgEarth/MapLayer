/* -*-c++-*- */
/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph
 * Copyright 2008-2010 Pelican Mapping
 * http://osgearth.org
 *
 * osgEarth is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */
#if 0
#ifndef OSGEARTH_MAP_LAYER_H
#define OSGEARTH_MAP_LAYER_H 1

#include <osgEarth/Common>
#include <osgEarth/Config>
#include <osgEarth/TileSource>
#include <osgEarth/Profile>
#include <osgEarth/Caching>
#include <osgEarth/TaskService>
#include <map>
#include <utility>
#include <queue>
#include <OpenThreads/Mutex>

namespace osgEarth
{
    //class MapLayer;

    class TerrainLayerOptions : public ConfigOptions
    {
    public:
        TerrainLayerOptions( const ConfigOptions& options =ConfigOptions() );

        /**
         * Gets the explicit profile setup for this map layer. By default, the layer will 
         * try to automatically determine the Profile from the tile source. This property
         * sets it explicitly instead.
         */
        optional<ProfileOptions>& profile() { return _profileConf; }
        const optional<ProfileOptions>& profile() const { return _profileConf; }

        /**
         * Gets or sets the minimum level of detail for which this layer should generate data.
         */
        optional<int>& minLevel() { return _minLevel; }
        const optional<int>& minLevel() const { return _minLevel; }

        /**
         * The maximum level of detail for which this layer should generate data.
         */
        optional<int>& maxLevel() { return _maxLevel; }
        const optional<int>& maxLevel() const { return _maxLevel; }

		/**
		 * Whether to render this layer with the map.
		 */        
        const optional<bool>& enabled() const { return _enabled; }
        void setEnabled( bool enabled );

		/**
		 * Whether to use exact cropping if image cropping is necessary
		 */
        optional<bool>& exactCropping() { return _exactCropping; }
        const optional<bool>& exactCropping() const { return _exactCropping; }

		/**
		 * The desired tile size to reproject imagery to if necessary.
		 */
        optional<unsigned int> reprojectedTileSize() { return _reprojectedTileSize; }
        const optional<unsigned int> reprojectedTileSize() const { return _reprojectedTileSize; }

		/**
		 * The format that this MapLayer should use when caching.
		 */
        optional<std::string>& cacheFormat() { return _cacheFormat; }
        const optional<std::string>& cacheFormat() const { return _cacheFormat; }

        /**
         * Whether to cache this layer or not.
         */
        optional<bool>& cacheEnabled() { return _cacheEnabled; }
        const optional<bool>& cacheEnabled() const { return _cacheEnabled; }

		/**
		 * Whether to try to run this MapLayer strictly from the cache only.
		 */
        optional<bool>& cacheOnly() { return _cacheOnly; }
        const optional<bool>& cacheOnly() const { return _cacheOnly; }
        
        /**
         * The loading weight of this MapLayer (for threaded loading policies).
         */
        optional<float>& loadingWeight() { return _loadingWeight; }
        const optional<float>& loadingWeight() const { return _loadingWeight; }

        /**
         * The ratio used to expand the extent of a tile when the layer
         * needs to be mosaiced to projected.  This can be used to increase the
         * number of tiles grabbed to ensure that enough data is grabbed to
         * overlap the incoming tile.
         */
        optional<double>& edgeBufferRatio() { return _edgeBufferRatio;}
        const optional<double>& edgeBufferRatio() const { return _edgeBufferRatio;}

        /**
         * A reference location that drivers can use to load data from relative locations.
         * NOTE: this is a runtime-only property and is NOT serialized in the ConfigOptions.
         */
        std::string& referenceURI() { return _referenceURI; }
        const std::string& referenceURI() const { return _referenceURI; }

    public:
        virtual Config getConfig() const;
        virtual void mergeConfig( const Config& conf );

    private:
        void fromConfig( const Config& conf );
       
        optional<ProfileOptions> _profile;
        optional<int> _minLevel;
        optional<int> _maxLevel;
		optional<std::string> _cacheFormat;
        optional<bool> _cacheEnabled;
		optional<bool> _cacheOnly;
        optional<float> _loadingWeight;
        optional<bool> _exactCropping;
		optional<bool> _enabled;
		optional<unsigned int> _reprojectedTileSize;
        optional<double> _edgeBufferRatio;

        std::string _referenceURI;
    };


    class OSGEARTH_EXPORT ImageLayerOptions : public TerrainLayerOptions
    {
    public:
        ImageLayerOptions( const ConfigOptions& options =ConfigOptions() ) :
          _opacity( 1.0f ),
          _gamma  ( 1.0f ),
          transparentColor( osg::Vec4ub(0,0,0,0) )
        { 
            fromConfig( _conf );
        }

    public: // properties

		/**
		 * The initial opacity of this layer
		 */
        optional<float>& opacity() { return _opacity; }
        const optional<float>& opacity() const { return _opacity; }

        /**
         * The initial gamma value for this layer's images
         */
        optional<double>& gamma() { return _gamma; }
        const optional<double>& gamma() const { return _gamma; }

		/**
		 * Gets or sets the nodata image for this MapLayer
		 */
        optional<std::string>& noDataImageFilename() { return _noDataImageFilename; }
        const optional<std::string>& noDataImageFilename() const { return _noDataImageFilename; }

		/**
		 * Gets the transparent color of this TileSource
		 */
		optional<osg::Vec4ub>& transparentColor() { return _transparentColor; }
        const optional<osg::Vec4ub>& transparentColor() const { return _transparentColor; }

        /**
         * The texture magnification mipmapping filter mode
         */
		optional<osg::Texture::FilterMode>& getMagFilter(void) {return _magFilter;}
		const optional<osg::Texture::FilterMode>& getMagFilter(void) const {return _magFilter;}

        /**
         * The texture minification mipmapping filter mode
         */
		optional<osg::Texture::FilterMode>& getMinFilter(void) {return _minFilter;}
		const optional<osg::Texture::FilterMode>& getMinFilter(void) const {return _minFilter;}

    public:
        virtual Config getConfig() const;
        virtual void mergeConfig( const Config& conf );
        
    private:
        void fromConfig( const Config& conf );

		optional<float> _opacity;
        optional<double> _gamma;
		optional<osg::Vec4ub> _transparentColor;
	    optional<std::string> _noDataImageFilename;
		optional<osg::Texture::FilterMode> _magFilter;
        optional<osg::Texture::FilterMode> _minFilter;   
    };


    class OSGEARTH_EXPORT ElevationLayerOptions : public TerrainLayerOptions
    {
    public:
        ElevationLayerOptions( const ConfigOptions& options =ConfigOptions() );

    public:
        virtual Config getConfig() const;
        virtual void mergeConfig( const Config& conf );
        
    private:
        void fromConfig( const Config& conf );            
    };




    class OSGEARTH_EXPORT TerrainLayer : public osg::Referenced
    {
    protected:
        TerrainLayer();

        virtual TerrainLayerOptions& getTerrainLayerOptions() const =0;

        void setEnabled( bool value );
        bool getEnabled() const { return _enabled; }

        /**
         * Gets the unique ID of this map layer
         */
        unsigned int getId() const;

        /**
         * Gets the readable name of the map layer.
         */
        const std::string& getName() const;

		/**
		 * Gets the profile of this MapLayer
		 */
		const Profile* getProfile() const;

        /**
         * Gets the underlying TileSource engine that serves this map layer. Use with caution.
         */
        TileSource* getTileSource() const;

		/**
		 *Gets the tile size of the this MapLayer
		 */
		unsigned int getTileSize() const;

		/**
		 *Gets the maximum data level of this MapLayer
		 */
		unsigned int getMaxDataLevel() const;

    public: // methods

		/**
		 * Whether the given key is valid for this layer
		 */
		bool isKeyValid(const TileKey& key) const;

		/**
		 * Gets the Cache to be used on this MapLayer.
		 */
		Cache* getCache() const;

		/**
		 * Sets the cache to be used on this MapLayer
         * TODO: is it legal to set this at any time?
		 */
		void setCache( Cache* cache );

        /**
         * Suggests a cache format for this layer
         */
        std::string suggestCacheFormat() const;

    protected:

		void initTileSource();

		void readEnvironmentalVariables();

    private:
        bool _enabled;

        unsigned int _id;
        std::string _name;

        bool _cacheOnlyEnv;

		unsigned int _tileSize;
        
        osg::ref_ptr<TileSource> _tileSource;
		osg::ref_ptr<Cache> _cache;

		osg::ref_ptr< const Profile > _profile;
        osg::ref_ptr< const Profile > _cacheProfile;
        
        //TODO: move this to a shader
        unsigned char _gammaLUT[256];
        double _prevGamma;

        OpenThreads::Mutex _initMutex;
        void init();

        void mergeConfig( const Config& conf );
    };


    class OSGEARTH_EXPORT ImageLayer : public TerrainLayer
    {
    public:
        ImageLayer( const ImageLayerOptions& options );

        const ImageLayerOptions& getImageLayerOptions() const { return _options; }
        const TerrainLayerOptions& getTerrainLayerOptions() const { return _options; }

    public: // properties

        void setOpacity( float opacity );
        float getOpacity() const;

    public: // methods

		/**
		 * Creates a GeoImage from this MapLayer
		 */
		GeoImage createImage( const TileKey& key, ProgressCallback* progress = 0);

    protected:

		osg::Image* createImageWrapper( const TileKey& key,
                                        bool cacheInLayerProfile,
                                        ProgressCallback* progress );

    private:
        ImageLayerOptions _options;
        float _opacity;	    
        osg::ref_ptr<osg::Image> _noDataImage;

        void postProcess( GeoImage& img );
    };


    class OSGEARTH_EXPORT ElevationLayer : public TerrainLayer
    {
    public:
        ElevationLayer( const ElevationLayerOptions& options );

        const ElevationLayerOptions& getElevationLayerOptions() const { return _options; }
        const TerrainLayerOptions& getTerrainLayerOptions() const { return _options; }

    public: // properties


    public: // methods

        /**
         * Creates a GeoHeightField for this MapLayer.
         * The returned HeightField will always match the geospatial extents of the incoming TileKey.
         */
        osg::HeightField* createHeightField( const TileKey& key, ProgressCallback* progress = 0);

    protected:
        
		GeoHeightField createGeoHeightField( const TileKey& key,
                                             ProgressCallback* progress);

    private:
        ElevationLayerOptions _options;
    };


#if 0

    /**
     * Controller interface for updating layer settings that can be changed at run-time.
     * internal class - no export
     */
    class MapLayerController : public osg::Referenced
    {
    public:
        virtual void updateOpacity( MapLayer* layer ) =0;
        virtual void updateEnabled( MapLayer* layer ) =0;
    };

    /**
     * One layer in the map.
     */
    class OSGEARTH_EXPORT MapLayer : public osg::Referenced
    {
    public:
        /**
         * Map layer data types.
         */
        enum Type {
            TYPE_IMAGE,
            TYPE_HEIGHTFIELD
        };

    public: //ctors

        /**
         * Constructs a new MapLayer with the specified options.
         */
        MapLayer( const string& name, const MapLayerOptions& options );

        /**
         * Constructs a new map layer with the specified driver options.
         */
        MapLayer(
            const std::string& name,
            Type type,
            const TileSourceOptions& options =TileSourceOptions() );

        /**
         * Constructs a new map layer based on information in a Config object. This is
         * the typical method for creating a layer from a serialized definition (like
         * the .earth file).
         */
        MapLayer(
            Type type,
            const Config& driverConf );

        /**
         * Constructs a new map layer with a user-provided TileSource driver.
         */
        MapLayer(
            const std::string& name,
            Type type,
            TileSource* driver );


    public: // properties

        /**
         * Gets the unique ID of this map layer
         */
        unsigned int getId() const;

        /**
         * Gets the readable name of the map layer.
         */
        const std::string& getName() const;

        /**
         * Gets the layer type of the map layer.
         */
        const Type& getType() const;

        /**
         * Gets the driver options used to create this layer.
         */
        const TileSourceOptions getTileSourceOptions() const {
            return _options; }

		/**
		 * Gets the profile of this MapLayer
		 */
		const Profile* getProfile() const;

        /**
         * Gets the underlying TileSource engine that serves this map layer. Use with caution.
         */
        TileSource* getTileSource() const;

		/**
		 *Gets the tile size of the this MapLayer
		 */
		unsigned int getTileSize() const;

		/**
		 *Gets the maximum data level of this MapLayer
		 */
		unsigned int getMaxDataLevel() const;

    public: // properties



    public: // methods

		/**
		 *Gets whether the given key is valid for this MapLayer
		 */
		bool isKeyValid(const TileKey& key) const;

		/**
		 * Creates a GeoImage from this MapLayer
		 */
		GeoImage createImage( const TileKey& key, ProgressCallback* progress = 0);

        /**
         * Creates a GeoHeightField for this MapLayer.
         * The returned HeightField will always match the geospatial extents of the incoming TileKey.
         */
        osg::HeightField* createHeightField( const TileKey& key, ProgressCallback* progress = 0);

		/**
         * Gets the reference URI. See setReferenceURI for more info.
         */
        const std::string& getReferenceURI() const;

        /**
         * Sets a reference URI. Usually this is the location of a file from which this map
         * was created. This acts as a reference point for any relative paths/URIS that may
         * occur elsewhere in the configuration.
         *
         * Note: Set this before adding any layers to the map.
         */
        void setReferenceURI( const std::string& uri );

		/**
		 * Gets the Cache to be used on this MapLayer.
		 */
		Cache* getCache() const;

		/**
		 * Sets the cache to be used on this MapLayer
		 */
		void setCache( Cache* cache );

        /**
         * Suggests a cache format for this layer
         */
        std::string suggestCacheFormat() const;

        
        virtual Config getConfig() const;

        /**
         * Applies a controller to this layer so that the terrain implementation
         * can update properties at runtime
         */
        void setController( MapLayerController* controller ) {
            _controller = controller;  }

    protected:

		void initTileSource();

		osg::Image* createImageWrapper( const TileKey& key,
                                        bool cacheInLayerProfile,
                                        ProgressCallback* progress );

		GeoHeightField createGeoHeightField( const TileKey& key,
                                             ProgressCallback* progress);

		void readEnvironmentalVariables();

        ~MapLayer() { }

    private:
        unsigned int _id;
        std::string _name;
        Type        _type;

        //osg::ref_ptr<const DriverOptions> _driverOptions;
        TileSourceOptions _options;

        bool _cacheOnlyEnv;

		unsigned int _tileSize;

        
        osg::ref_ptr<TileSource> _tileSource;
		osg::ref_ptr<Cache> _cache;
	    osg::ref_ptr<osg::Image> _nodata_image;

		std::string _referenceURI;

		osg::ref_ptr< const Profile > _profile;
        osg::ref_ptr< const Profile > _cacheProfile;

        OpenThreads::Mutex _initMutex;
        
        unsigned char _gammaLUT[256];
        double _prevGamma;

        void init();
        void mergeConfig( const Config& conf );
        void postProcess( GeoImage& img );

        osg::observer_ptr<MapLayerController> _controller;
    };

    /**
     * Convenience class that automatically sets the TYPE_IMAGE layer type.
     */
    class OSGEARTH_EXPORT ImageMapLayer : public MapLayer
    {
    public:
        ImageMapLayer( const std::string& name, const TileSourceOptions& options ) :
          MapLayer( name, MapLayer::TYPE_IMAGE, options ) { }
        
        ImageMapLayer( const std::string& name, TileSource* source ) :
          MapLayer( name, MapLayer::TYPE_IMAGE, source ) { }
    };
    
    class OSGEARTH_EXPORT HeightFieldMapLayer : public MapLayer
    {
    public:
        HeightFieldMapLayer( const std::string& name, const TileSourceOptions& options ) :
          MapLayer( name, MapLayer::TYPE_HEIGHTFIELD, options ) { }
        
        HeightFieldMapLayer( const std::string& name, TileSource* source ) :
          MapLayer( name, MapLayer::TYPE_HEIGHTFIELD, source ) { }
    };


    typedef std::vector< osg::ref_ptr<MapLayer> > MapLayerList;

	class TransparentLayer : public osgTerrain::ImageLayer
	{
	public:
		TransparentLayer(osg::Image* image, MapLayer* mapLayer):
			osgTerrain::ImageLayer(image),
		    _mapLayer(mapLayer),
            _lod(-1)
		{
		}

        unsigned int getId() const
        {
            return _mapLayer->getId();
        }

		float getOpacity() const
		{
            return _mapLayer->opacity().value();
		}

		bool getEnabled() const
		{
			return _mapLayer->enabled().value();
		}

        int getLevelOfDetail() const
        {
            return _lod;
        }

        void setLevelOfDetail(int lod)
        {
            _lod = lod;
        }

		MapLayer* getMapLayer() const
		{
			return _mapLayer.get();
		}

		osg::ref_ptr<MapLayer> _mapLayer;
        int _lod;
	};
#endif

#if 0
    class OSGEARTH_EXPORT L2Cache
    {
    public:
        L2Cache();
        GeoImage& createImage( MapLayer* layer, const TileKey& key );
        osg::HeightField* createHeightField( MapLayer* layer, const TileKey& key );
    public:
        typedef std::pair<MapLayer*,std::string> TileTag;
        typedef std::map<TileTag,osg::ref_ptr<osg::Referenced> > TileMap;
        typedef std::queue<TileTag> TileTagQueue;
        struct TileCache {
            TileCache() : _hits(0), _misses(0) { }
            TileMap _map;
            TileTagQueue _fifo;
            OpenThreads::Mutex _mutex;
            void put(const TileTag& tag, osg::Referenced* obj);
            osg::Referenced* get(const TileTag& tag);
            int _hits, _misses;
        };

    protected:
        TileCache _cache;
        TaskService* _service;
        void scheduleSubKeys(MapLayer*,const TileKey&);
    };
#endif

}

#endif // OSGEARTH_MAP_LAYER_H
#endif