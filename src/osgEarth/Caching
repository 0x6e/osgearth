/* -*-c++-*- */
/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph
* Copyright 2008-2010 Pelican Mapping
* http://osgearth.org
*
* osgEarth is free software; you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>
*/

#ifndef OSGEARTH_CACHING_H
#define OSGEARTH_CACHING_H 1

#include <osgEarth/Common>
#include <osgEarth/Config>
#include <osgEarth/DriverOptions>
#include <osgEarth/TMS>
#include <osgEarth/TileKey>

#include <osg/Referenced>
#include <osg/Object>
#include <osg/Image>
#include <osg/Shape>
#include <osg/Timer>
#include <osgDB/ReadFile>

#include <OpenThreads/ReadWriteMutex>

#include <string>

namespace osgEarth
{   

  /**
  * Defines the properties for a cache.
  * TO BE DEPRECATED, probably in version 2.0, and replaced by a DriverOptions-compatible structure.
  */
  class OSGEARTH_EXPORT CacheConfig
  {
  public:
      typedef std::string CacheType;

      static const CacheType TYPE_DEFAULT;   // = "";
      static const CacheType TYPE_TMS;       // = "tms";
      static const CacheType TYPE_TILECACHE; // = "tilecache";

  public:
    /**
    * Constructs a new cache configuration
    */
    CacheConfig();

    /** materialize from a configuration object */
    CacheConfig( const Config& conf );

    /**
    * Gets the cache type identifier.
    */
    const CacheType& getType() const;

    /**
    * Sets the cache type identifier
    */
    void setType(const CacheType& type);

    /**
     * Access to the configuration object for the cache driver.
     */
    Config& getDriverConf() { return _driverConf; }

    /**
    * Sets whether the map engine should only pull tiles from the cache and not from
    * an end tile source. Forces a sort of "offline" mode.
    */
    optional<bool>& runOffCacheOnly();
    const optional<bool>& runOffCacheOnly() const;

    std::string toString() const;

    /** Serializes this object's settings. */
    void fromConfig( const Config& conf );
    Config toConfig( const std::string& name ="cache" ) const;

  private:
    CacheType       _type;
    //Properties      _properties;
    Config          _driverConf;
    optional<bool>  _runOffCacheOnly;
  };

  /**
   * Base class for a Cache that stores image tiles
   */
  class OSGEARTH_EXPORT Cache : public osg::Object
  {
  public:

    /**
    * Gets the cached image for the given TileKey
    */
    virtual osg::Image* getImage( const TileKey* key,
      const std::string& layerName,
      const std::string& format ) = 0;

    /**
    * Sets the cached image for the given TileKey
    */
    virtual void setImage( const TileKey* key,
      const std::string& layerName,
      const std::string& format,
      osg::Image* image ) = 0;

    /**
    * Gets the cached heightfield for the given TileKey
    */
    virtual osg::HeightField* getHeightField( const TileKey* key,
      const std::string& layerName,
      const std::string& format);

    /**
    * Sets the cached heightfield for the given TileKey
    */
    virtual void setHeightField( const TileKey* key,
      const std::string& layerName,
      const std::string& format,
      osg::HeightField* hf );

    /**
    * Gets the current MapConfig filename.  This is used for getting relative paths to the MapConfig.
    */
    virtual const std::string& getMapConfigFilename() {return _mapConfigFilename;}

    /**
    * Sets the current MapConfig filename.
    */
    virtual void setMapConfigFilename( const std::string &mapConfigFilename ) { _mapConfigFilename = mapConfigFilename;}

    /**
    * Gets whether the given TileKey is cached or not
    */
    virtual bool isCached( const TileKey* key,
      const std::string& layerName,
      const std::string& format) const { return false; }

    /**
    * Store the TileMap for the given profile.
    */
    virtual void storeLayerProperties( const std::string& layerName,
      const Profile* profile,
      const std::string& format,
      unsigned int tile_size);

    /**
    * Loads the TileMap for the given layer.
    */
    virtual const Profile* loadLayerProperties( const std::string& layerName,
      std::string& format,
      unsigned int &tile_size );

    /**
     * Compact the cache, if supported by the underlying implementation.
     * You can optionally specify that the compaction operation run in 
     * a background thread if supported.
     *
     * This method will return false if the implementation does not support
     * compaction.
     */
    virtual bool compact( bool async =true ) { return false; }

    /**
     * Delete old entries from the cache. The timestamp is UTC, second since epoch.
     * You can optionally control whether the purge operation should run in the
     * background (async=true) if supported.
     *
     * This method will return false if the implementation does not support 
     * the operation.
     */
    virtual bool purge(
        const std::string& layerName,
        int olderThanTimeStamp =0L,
        bool async =true ) { return false; }

  protected:

    Cache();
    Cache(const Cache& rhs, const osg::CopyOp& op =osg::CopyOp::DEEP_COPY_ALL);

    std::string _mapConfigFilename;
  };

  /**
   * In-memory image tile cache.
   */
  class OSGEARTH_EXPORT MemCache : public Cache
  {
  public:
    MemCache();
    MemCache( const MemCache& rhs, const osg::CopyOp& op =osg::CopyOp::DEEP_COPY_ALL );
    META_Object(osgEarth,MemCache);

    /**
    * Gets the maximum number of tiles to keep in the cache
    */
    unsigned int getMaxNumTilesInCache() const;

    /**
    * Sets the maximum number of tiles to keep in the cache
    */
    void setMaxNumTilesInCache(unsigned int max);

    /**
    * Gets whether the given TileKey is cached or not
    */
    virtual bool isCached( const TileKey* key,
      const std::string& layerName,
      const std::string& format);

    /**
    * Gets the cached image for the given TileKey
    */
    virtual osg::Image* getImage( const TileKey* key,
      const std::string& layerName,
      const std::string& format);

    /**
    * Sets the cached image for the given TileKey
    */
    virtual void setImage( const TileKey* key,
      const std::string& layerName,
      const std::string& format,
      osg::Image* image);

    /**
    * Gets the cached heightfield for the given TileKey
    */
    virtual osg::HeightField* getHeightField( const TileKey* key,
      const std::string& layerName,
      const std::string& format);

    /**
    * Sets the cached heightfield for the given TileKey
    */
    virtual void setHeightField( const TileKey* key,
      const std::string& layerName,
      const std::string& format,
      osg::HeightField* hf);

    /** Delete entries from the cache. */
    virtual bool purge(
        const std::string& layerName,
        int olderThan,
        bool async );

  protected:
    /**
    * Gets the cached object for the given TileKey
    */
    osg::Referenced* getObject( const TileKey* key,
      const std::string& layerName,
      const std::string& format);

    /**
    * Sets the cached object for the given TileKey
    */
    void setObject( const TileKey* key,
      const std::string& layerName,
      const std::string& format,
      osg::Referenced* image );

    struct CachedObject
    {
      std::string _key;
      osg::ref_ptr<osg::Referenced> _object;
    };

    typedef std::list<CachedObject> ObjectList;
    ObjectList _objects;

    typedef std::map<std::string,ObjectList::iterator> KeyToIteratorMap;
    KeyToIteratorMap _keyToIterMap;

    unsigned int _maxNumTilesInCache;
    OpenThreads::Mutex _mutex;

  };

  /**
   * Base class for any cache that stores image tile files to disk
   */
  class OSGEARTH_EXPORT DiskCache : public Cache
  {
  public:
    DiskCache();

    DiskCache(const std::string& path);

    DiskCache( const DiskCache& rhs, const osg::CopyOp& op =osg::CopyOp::DEEP_COPY_ALL );

    META_Object(osgEarth,DiskCache);

    /**
    * Gets the path of this DiskCache
    */
    std::string getPath() const;

    /**
    *Sets the path of this DiskCache
    */
    const void setPath(const std::string& path) { _path = path; }

    /**
    * Gets weather or not to write a world file along with the cached image
    */
    bool getWriteWorldFiles() const { return _writeWorldFiles; }

    /**
    * Sets weather or not to write a world file along with the cached image
    */
    void setWriteWorldFiles(bool writeWorldFiles) { _writeWorldFiles = writeWorldFiles; }

    /**
    * Gets whether the given TileKey is cached or not
    */
    virtual bool isCached( const TileKey* key,
      const std::string& layerName,
      const std::string& format) const;

    /**
    * Gets the filename to cache to for the given TileKey
    */
    virtual std::string getFilename( const TileKey* key,
      const std::string& layerName,
      const std::string& format) const;

    /**
    * Gets the cached image for the given TileKey
    */
    virtual osg::Image* getImage( const TileKey* key,
      const std::string& layerName,
      const std::string& format);

    /**
    * Sets the cached image for the given TileKey
    */
    virtual void setImage( const TileKey* key,
      const std::string& layerName,
      const std::string& format,
      osg::Image* image);

    /**
    * Store the TileMap for the given profile.
    */
    virtual void storeLayerProperties( const std::string& layerName,
      const Profile* profile,
      const std::string& format,
      unsigned int tile_size);

    /**
    * Loads the TileMap for the given layer.
    */
    virtual const Profile* loadLayerProperties( const std::string& layerName,
      std::string& format,
      unsigned int &tile_size );


  protected:
    std::string getTMSPath(const std::string &layerName);

    struct LayerProperties
    {
      std::string _format;
      unsigned int _tile_size;
      osg::ref_ptr< const Profile > _profile;
    };

    typedef std::map< std::string, LayerProperties > LayerPropertiesCache;
    LayerPropertiesCache _layerPropertiesCache;
    std::string _path;
    bool        _writeWorldFiles;       
  };

  /**
   * Disk-based cache that stores image tiles according the the OSGeo TMS specification.
   */
  class OSGEARTH_EXPORT TMSCache : public DiskCache
  {
  public:
    TMSCache() { }

    TMSCache(const std::string &path );

    TMSCache(const TMSCache& rhs, const osg::CopyOp& op =osg::CopyOp::DEEP_COPY_ALL);

    META_Object(osgEarth,TMSCache);

    /**
    * Gets whether or not to invert the y tile index
    */
    const bool& getInvertY() {return _invertY; }

    /**
    * Sets whether or not to invert the y tile index
    */
    void setInvertY(const bool &invertY) {_invertY = invertY;}

    /**
    * Gets the filename to cache to for the given TileKey
    */
    virtual std::string getFilename( const TileKey* key,
      const std::string& layerName,
      const std::string& format) const;

  private:
    bool _invertY;
  };


  /**
  * CacheFactory is used to created CachedTileSource's from configuration properties.
  */
  class OSGEARTH_EXPORT CacheFactory
  {
  public:
    /**
     * Creates a Cache from the given CacheConfig
     * (note: to be deprecated)
     */
    Cache* create(const CacheConfig& cacheConfig);

    /**
     * Creates a cache from the provided DriverOptions class (new method)
     */
    Cache* create( const DriverOptions* options );
  };

}

#endif // OSGEARTH_CACHING_H
