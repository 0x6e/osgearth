/* -*-c++-*- */
/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph
* Copyright 2008-2010 Pelican Mapping
* http://osgearth.org
*
* osgEarth is free software; you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>
*/

#ifndef OSGEARTH_CACHING_H
#define OSGEARTH_CACHING_H 1

#include <osgEarth/Common>
#include <osgEarth/Config>
#include <osgEarth/DriverOptions>
#include <osgEarth/TMS>
#include <osgEarth/TileKey>

#include <osg/Referenced>
#include <osg/Object>
#include <osg/Image>
#include <osg/Shape>
#include <osg/Timer>
#include <osgDB/ReadFile>

#include <OpenThreads/ReadWriteMutex>

#include <string>

namespace osgEarth
{
    /**
     * Base class for Cache implementation options.
     */
    class CacheOptions : public DriverConfigOptions // no export (header only)
    {
    public:
        CacheOptions( const ConfigOptions& options =ConfigOptions() )
            : DriverConfigOptions( options ),
              _cacheOnly( false )
        { 
            fromConfig( _conf ); 
        }

        /** Whether to run exclusively off the cache (and not fetch files from tile sources) */
        optional<bool> cacheOnly() { return _cacheOnly; }
        const optional<bool> cacheOnly() const { return _cacheOnly; }

    public:
        virtual Config getConfig() const {
            Config conf = ConfigOptions::getConfig();
            conf.updateIfSet( "cache_only", _cacheOnly );
            return conf;
        }
        virtual void mergeConfig( const Config& conf ) {
            ConfigOptions::mergeConfig( conf );            
            fromConfig( conf );
        }
    private:
        void fromConfig( const Config& conf ) {
            conf.getIfSet( "cache_only", _cacheOnly );
        }

        optional<bool> _cacheOnly;
    };

    class DiskCacheOptions : public CacheOptions
    {
    public:
        DiskCacheOptions( const ConfigOptions& options =ConfigOptions() )
            : CacheOptions( options ),
              _writeWorldFiles( false )
        {
            fromConfig( _conf );
        }

        /** The folder path in which to store the cache data */
        void setPath( const std::string& value ) { _path = value; }
        const std::string& path() const { return _path; }

        /** Whether to write out "world" files alongside the cached tiles */
        optional<bool>& writeWorldFiles() { return _writeWorldFiles; }
        const optional<bool>& writeWorldFiles() const { return _writeWorldFiles; }

    public:
        virtual Config getConfig() const {
            Config conf = CacheOptions::getConfig();
            conf.value("path") = _path;
            conf.updateIfSet("write_world_files", _writeWorldFiles);
            return conf;
        }
        virtual void mergeConfig( const Config& conf ) {
            CacheOptions::mergeConfig( conf );
            fromConfig( conf );
        }

    private:
        void fromConfig( const Config& conf ) {
            _path = conf.value("path");
            conf.getIfSet("write_world_files", _writeWorldFiles);
        }

        std::string    _path;
        optional<bool> _writeWorldFiles;
    };

    /**
     * TMS-style disk cache options.
     */
    class TMSCacheOptions : public DiskCacheOptions // no export (header only)
    {
    public:
        TMSCacheOptions( const ConfigOptions& options =ConfigOptions() )
            : DiskCacheOptions( options ),
              _invertY( false )
        {
            fromConfig( _conf );
        }

        /** Wheher to invert the Y tile indicies ("google type") */
        optional<bool>& invertY() { return _invertY; }
        const optional<bool>& invertY() const { return _invertY; }

    public:
        virtual Config getConfig() const {
            Config conf = DiskCacheOptions::getConfig();
            conf.updateIfSet("invert_y", _invertY);
            return conf;
        }
        virtual void mergeConfig( const Config& conf ) {
            DiskCacheOptions::mergeConfig( conf );
            fromConfig( conf );
        }

    private:
        void fromConfig( const Config& conf ) {
            conf.getIfSet("invert_y", _invertY);
        }

        optional<bool> _invertY;
    };

#if 0
  /**
  * Defines the properties for a cache.
  * TO BE DEPRECATED, probably in version 2.0, and replaced by a DriverOptions-compatible structure.
  */
  class OSGEARTH_EXPORT CacheConfig
  {
  public:
      typedef std::string CacheType;

      static const CacheType TYPE_DEFAULT;   // = "";
      static const CacheType TYPE_TMS;       // = "tms";
      static const CacheType TYPE_TILECACHE; // = "tilecache";

  public:
    /**
    * Constructs a new cache configuration
    */
    CacheConfig();

    /** materialize from a configuration object */
    CacheConfig( const Config& conf );

    /**
    * Gets the cache type identifier.
    */
    const CacheType& getType() const;

    /**
    * Sets the cache type identifier
    */
    void setType(const CacheType& type);

    /**
     * Access to the configuration object for the cache driver.
     */
    Config& getDriverConf() { return _driverConf; }

    /**
    * Sets whether the map engine should only pull tiles from the cache and not from
    * an end tile source. Forces a sort of "offline" mode.
    */
    optional<bool>& runOffCacheOnly();
    const optional<bool>& runOffCacheOnly() const;

    std::string toString() const;

    /** Serializes this object's settings. */
    void mergeConfig( const Config& conf );
    Config getConfig( const std::string& name ="cache" ) const;

  private:
    CacheType       _type;
    //Properties      _properties;
    Config          _driverConf;
    optional<bool>  _runOffCacheOnly;
  };
#endif

  /**
   * Base class for a Cache that stores image tiles
   */
  class OSGEARTH_EXPORT Cache : public osg::Object
  {
  public:
    /**
    * Gets the cached image for the given TileKey
    */
    virtual osg::Image* getImage( const TileKey& key,
      const std::string& layerName,
      const std::string& format ) = 0;

    /**
    * Sets the cached image for the given TileKey
    */
    virtual void setImage( const TileKey& key,
      const std::string& layerName,
      const std::string& format,
      osg::Image* image ) = 0;

    /**
    * Gets the cached heightfield for the given TileKey
    */
    virtual osg::HeightField* getHeightField( const TileKey& key,
      const std::string& layerName,
      const std::string& format);

    /**
    * Sets the cached heightfield for the given TileKey
    */
    virtual void setHeightField( const TileKey& key,
      const std::string& layerName,
      const std::string& format,
      osg::HeightField* hf );

    /**
    * Gets the current MapConfig filename.  This is used for getting relative paths to the MapConfig.
    */
    virtual const std::string& getReferenceURI() { return _refURI; }

    /**
    * Sets the current MapConfig filename.
    */
    virtual void setReferenceURI( const std::string& value ) { _refURI = value; }

    /**
    * Gets whether the given TileKey is cached or not
    */
    virtual bool isCached( const TileKey& key,
      const std::string& layerName,
      const std::string& format) const { return false; }

    /**
    * Store the TileMap for the given profile.
    */
    virtual void storeLayerProperties( const std::string& layerName,
      const Profile* profile,
      const std::string& format,
      unsigned int tile_size) { }

    /**
    * Loads the TileMap for the given layer.
    */
    virtual const Profile* loadLayerProperties( const std::string& layerName,
      std::string& format,
      unsigned int &tile_size ) { return 0L; }

    /**
     * Compact the cache, if supported by the underlying implementation.
     * You can optionally specify that the compaction operation run in 
     * a background thread if supported.
     *
     * This method will return false if the implementation does not support
     * compaction.
     */
    virtual bool compact( bool async =true ) { return false; }

    /**
     * Delete old entries from the cache. The timestamp is UTC, second since epoch.
     * You can optionally control whether the purge operation should run in the
     * background (async=true) if supported.
     *
     * This method will return false if the implementation does not support 
     * the operation.
     */
    virtual bool purge(
        const std::string& layerName,
        int olderThanTimeStamp =0L,
        bool async =true ) { return false; }

  public:
      Cache( const CacheOptions& options =CacheOptions() );
      Cache( const Cache& rhs, const osg::CopyOp& op =osg::CopyOp::DEEP_COPY_ALL );

  protected:
      std::string _refURI;
  };

  /**
   * In-memory image tile cache.
   */
  class OSGEARTH_EXPORT MemCache : public Cache
  {
  public:
    MemCache();
    MemCache( const MemCache& rhs, const osg::CopyOp& op =osg::CopyOp::DEEP_COPY_ALL );
    META_Object(osgEarth,MemCache);

    /**
    * Gets the maximum number of tiles to keep in the cache
    */
    unsigned int getMaxNumTilesInCache() const;

    /**
    * Sets the maximum number of tiles to keep in the cache
    */
    void setMaxNumTilesInCache(unsigned int max);

    /**
    * Gets whether the given TileKey is cached or not
    */
    virtual bool isCached( const TileKey& key,
      const std::string& layerName,
      const std::string& format);

    /**
    * Gets the cached image for the given TileKey
    */
    virtual osg::Image* getImage( const TileKey& key,
      const std::string& layerName,
      const std::string& format);

    /**
    * Sets the cached image for the given TileKey
    */
    virtual void setImage( const TileKey& key,
      const std::string& layerName,
      const std::string& format,
      osg::Image* image);

    /**
    * Gets the cached heightfield for the given TileKey
    */
    virtual osg::HeightField* getHeightField( const TileKey& key,
      const std::string& layerName,
      const std::string& format);

    /**
    * Sets the cached heightfield for the given TileKey
    */
    virtual void setHeightField( const TileKey& key,
      const std::string& layerName,
      const std::string& format,
      osg::HeightField* hf);

    /** Delete entries from the cache. */
    virtual bool purge(
        const std::string& layerName,
        int olderThan,
        bool async );

  protected:
    /**
    * Gets the cached object for the given TileKey
    */
    osg::Referenced* getObject( const TileKey& key,
      const std::string& layerName,
      const std::string& format);

    /**
    * Sets the cached object for the given TileKey
    */
    void setObject( const TileKey& key,
      const std::string& layerName,
      const std::string& format,
      osg::Referenced* image );

    struct CachedObject
    {
      std::string _key;
      osg::ref_ptr<osg::Referenced> _object;
    };

    typedef std::list<CachedObject> ObjectList;
    ObjectList _objects;

    typedef std::map<std::string,ObjectList::iterator> KeyToIteratorMap;
    KeyToIteratorMap _keyToIterMap;

    unsigned int _maxNumTilesInCache;
    OpenThreads::Mutex _mutex;

  };

  /**
   * Base class for any cache that stores image tile files to disk
   */
  class OSGEARTH_EXPORT DiskCache : public Cache
  {
  public:
    DiskCache( const DiskCacheOptions& options =DiskCacheOptions() );

    DiskCache( const DiskCache& rhs, const osg::CopyOp& op =osg::CopyOp::DEEP_COPY_ALL );

    META_Object(osgEarth,DiskCache);

    /**
    * Gets the path of this DiskCache
    */
    std::string getPath() const;

    ///**
    //*Sets the path of this DiskCache
    //*/
    //const void setPath(const std::string& path) { _path = path; }

    ///**
    //* Gets weather or not to write a world file along with the cached image
    //*/
    //bool getWriteWorldFiles() const { return _writeWorldFiles; }

    ///**
    //* Sets weather or not to write a world file along with the cached image
    //*/
    //void setWriteWorldFiles(bool writeWorldFiles) { _writeWorldFiles = writeWorldFiles; }

    /**
    * Gets whether the given TileKey is cached or not
    */
    virtual bool isCached( const TileKey& key,
      const std::string& layerName,
      const std::string& format) const;

    /**
    * Gets the filename to cache to for the given TileKey
    */
    virtual std::string getFilename( const TileKey& key,
      const std::string& layerName,
      const std::string& format) const;

    /**
    * Gets the cached image for the given TileKey
    */
    virtual osg::Image* getImage( const TileKey& key,
      const std::string& layerName,
      const std::string& format);

    /**
    * Sets the cached image for the given TileKey
    */
    virtual void setImage( const TileKey& key,
      const std::string& layerName,
      const std::string& format,
      osg::Image* image);

    /**
    * Store the TileMap for the given profile.
    */
    virtual void storeLayerProperties( const std::string& layerName,
      const Profile* profile,
      const std::string& format,
      unsigned int tile_size);

    /**
    * Loads the TileMap for the given layer.
    */
    virtual const Profile* loadLayerProperties( const std::string& layerName,
      std::string& format,
      unsigned int &tile_size );


  protected:
    std::string getTMSPath(const std::string &layerName);

    struct LayerProperties
    {
      std::string _format;
      unsigned int _tile_size;
      osg::ref_ptr< const Profile > _profile;
    };

    typedef std::map< std::string, LayerProperties > LayerPropertiesCache;
    LayerPropertiesCache _layerPropertiesCache;
    //std::string _path;
    bool        _writeWorldFilesOverride;     

  private:
      DiskCacheOptions _options;
  };

  /**
   * Disk-based cache that stores image tiles according the the OSGeo TMS specification.
   */
  class OSGEARTH_EXPORT TMSCache : public DiskCache
  {
  public:
    TMSCache(const TMSCacheOptions& options =TMSCacheOptions() );

    TMSCache(const TMSCache& rhs, const osg::CopyOp& op =osg::CopyOp::DEEP_COPY_ALL);
    META_Object(osgEarth,TMSCache);

    /**
    * Gets whether or not to invert the y tile index
    */
    const bool& getInvertY() {return _invertY; }

    /**
    * Sets whether or not to invert the y tile index
    */
    void setInvertY(const bool &invertY) {_invertY = invertY;}

    /**
    * Gets the filename to cache to for the given TileKey
    */
    virtual std::string getFilename( const TileKey& key,
      const std::string& layerName,
      const std::string& format) const;

  private:
    bool _invertY;
    TMSCacheOptions _options;
  };

  //----------------------------------------------------------------------

  class OSGEARTH_EXPORT CacheDriver : public osgDB::ReaderWriter
  {
  public:
      const CacheOptions& getCacheOptions( const osgDB::ReaderWriter::Options* options ) const;
  };

  //----------------------------------------------------------------------

  class OSGEARTH_EXPORT CacheFactory
  {
  public:
      static Cache* create( const CacheOptions& options );
  };
}

#endif // OSGEARTH_CACHING_H
