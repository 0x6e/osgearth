/* -*-c++-*- */
/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph
 * Copyright 2008-2009 Pelican Ventures, Inc.
 * http://osgearth.org
 *
 * osgEarth is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */

#ifndef OSGEARTH_MAP_CONFIG_H
#define OSGEARTH_MAP_CONFIG_H 1

#include <osg/Version>
#include <osgEarth/Common>
#include <osgEarth/Profile>
#include <osgEarth/TileSource>
#if OSG_MIN_VERSION_REQUIRED(2,9,5)
#include <osgDB/Options>
#endif
#include <osgDB/ReaderWriter>
#include <OpenThreads/ReadWriteMutex>
#include <map>
#include <list>

#include <osg/Vec4ub>

namespace osgEarth
{
    typedef std::map<std::string,std::string> CacheProperties;

    /**
     * Defines the properties for a cache.
     */
    class OSGEARTH_EXPORT CacheConfig
    {
    public:
        enum CacheType
        {
            TYPE_UNDEFINED, // the config is undefined and should be ignored
            TYPE_NONE,      // explicitly specify that no caching should occur
            TYPE_TMS,       // cache to a OSGeo Tile Map Service structure
            TYPE_TILECACHE  // cache to a MetaCarta Labs TileCache structure
        };

    public:
        /**
         * Constructs a new cache configuration
         */
        CacheConfig();

        // Copy constructor
        CacheConfig( const CacheConfig& rhs );

        /**
         * Returned True if this cache is well defined (not empty)
         */
        bool defined() const;

        /**
         * Gets the cache type identifier.
         */
        const CacheType& getType() const;

        /**
         * Sets the cache type identifier
         */
        void setType(const CacheType& type);

        /**
         * Gets the collection of name/value pairs for the cache. These will be particular
         * to each cache type implementation.
         */
        CacheProperties& getProperties();

        /**
         * Sets the collection of name/value pairs assoicated with the cache config.
         */
        const CacheProperties& getProperties() const;

        /**
         * Inherits properties from the given CacheConfig
         */
        void inheritFrom( const CacheConfig& rhs );

    private:
        CacheType       _type;
        CacheProperties _properties;
    };


    /**
     * Configures a geospatial profile, defining the spatial reference and tile layout
     * structure of map content.
     */
    class OSGEARTH_EXPORT ProfileConfig
    {
    public:
        /** Constructs an empty (undefined) profile configuration */
        ProfileConfig();

        /** Copy constructor. */
        ProfileConfig( const ProfileConfig& rhs );

        /** Constructs a profile configuration and sets the named profile. */
        ProfileConfig( const std::string& named_profile );

        /** Returns true if this configuration is well-defined and usable */
        bool defined() const;

        /** Gets the optional Well-Known Profile string. */
        const std::string& getNamedProfile() const;

        /** Sets an optional Well-Known Profile string. */
        void setNamedProfile( const std::string& namedProfile);

        /** Sets the name of a reference layer whose profile to use. */
        const std::string& getRefLayer() const;

        /** Gets the name of a reference layer whose profile to use. */         
        void setRefLayer(const std::string& refLayer);

        /** Sets the spatial reference system initialization string to use for the profile. */
        const std::string& getSRS() const;

        /** Gets the spatial reference system initialization string to use for the profile. */
        void setSRS(const std::string& srs);

        /** Returns true is the extents are set and form a valid spatial envelope. */         
        bool areExtentsValid() const;
        
        /** Gets the spatial extents of the profile */
        void getExtents(double &minX, double &minY, double &maxX, double &maxY) const;

        /** Sets the spatial extents of the profile */
        void setExtents(double minX, double minY, double maxX, double maxY);

    private:
        bool _empty;
        std::string _namedProfile;
        std::string _refLayer;
        std::string _srs;
        double _minX;
        double _minY;
        double _maxX;
        double _maxY;
    };


    typedef std::map<std::string,std::string> SourceProperties;


    /**
     * Defines a source for image or heightfield data. This is the configuration
     * information for a TileSource.
     */
    class OSGEARTH_EXPORT SourceConfig
    {
    public:
        /**
         * Constructs a new, empty tile source configuration.
         */
        SourceConfig();

        /**
         * Copy constructor. 
         */
        SourceConfig( const SourceConfig& rhs );

        /**
         * Creates a new source configuration with the given name and driver name.
         */
        SourceConfig(
            const std::string& name,
            const std::string& driver );

        /**
         * Creates a new source configuration with the given name, driver name, and
         * driver-specific property set.
         */
        SourceConfig(
            const std::string& name,
            const std::string& driver,
            const SourceProperties& props );


        /**
         * Returns true if this source config is sufficiently populated
         */
        bool isValid() const;

        /**
         * Sets the readable name of the source. This must be unique across
         * all sources.
         */
        void setName( const std::string& name );

        /**
         * Gets the readable name of the source.
         */
        const std::string& getName() const;

		/**
		 * Gets whether or not to reproject the data before caching occurs
		 */
		bool getReprojectBeforeCaching() const;

		/**
		 * Sets whether to reproject the data before caching occurs
		 */
		void setReprojectBeforeCaching(bool reprojectBeforeCaching);

        /**
         * Sets the driver name for this source. The driver name is the
         * name of the extension that will load the appropriate osg plugin.
         */
        void setDriver( const std::string& driver );

        const std::string& getDriver() const;

        /**
         * Gets the collection of name/value pairs that the tile generator
         * will pass to the OSG plugin designated by the driver setting.
         */
        SourceProperties& getProperties();

        /**
         * Gets the collection of name/value pairs that the tile generator
         * will pass to the OSG plugin designated by the driver setting.
         */
        const SourceProperties& getProperties() const;

        /**
         * Sets a source property - a name/value pair that the TileSource itself
         * will interpret
         */
        void setProperty( const std::string& name, const std::string& value );

        /**
         * Get or set properties using the indexer notation.
         */
        const std::string& operator [] ( const std::string& name ) const;
        std::string& operator [] ( const std::string& name );

        /**
         * Gets the caching configuration for this source, if one is set.
         */
        const CacheConfig& getCacheConfig() const;
        
        /**
         * Sets the caching configuration for this source. By default a tile
         * source will use the map's caching configuration, but you can override
         * it for each source.
         */
        void setCacheConfig( const CacheConfig& cacheConfig );

        /**
         * Gets the explicity profile override configuration for this source.
         */
        const ProfileConfig& getProfileConfig() const;

        /** 
         * Sets an explicity profile for this source. Usually the source will report
         * its own profile; but in rare cases you may need to explicity override it
         * using this method.
         */
        void setProfileConfig( const ProfileConfig& conf );

    private:
        std::string _name;
        std::string _driver;
		bool        _reprojectBeforeCaching;
        SourceProperties _properties;
        CacheConfig _cache_config;
        ProfileConfig _profile_config;
    };

    typedef std::list< SourceConfig > SourceConfigList;


    /**
     * Top-level map configuration. This is the data model behind a
     * ".earth" file.
     */
    class OSGEARTH_EXPORT MapConfig
    {
    public:
        // CS of the 3D scene
        enum CoordinateSystemType
        {
            CSTYPE_GEOCENTRIC,
            CSTYPE_GEOCENTRIC_CUBE,
            CSTYPE_PROJECTED
        };

    public:
        /**
         * Constructs a new, empty map configuration.
         */
        MapConfig();

        /**
         * Copy constructor 
         */
        MapConfig( const MapConfig& rhs );

        /**
         * Assignment operator
         */
        MapConfig& operator= (const MapConfig &rhs);

        /**
        *Gets the id of this MapConfig
        */
        unsigned int getId() const;

        /**
        *Sets the id of this MapConfig
        */
        void setId( unsigned int id );

        /**
         * Sets the readable name of the map.
         */
        void setName( const std::string& name );

        /** 
         * Gets the readable name of the map.
         */
        const std::string& getName() const;
        
        /**
         * Gets the coordinate system type for the geometry to create for this
         * map, e.g. round-earth (geocentric) or flat-earth (geographic, etc.)
         *
         * @return A CoordinateSystemType
         */
        const CoordinateSystemType& getCoordinateSystemType() const;

        /**
         * Sets the coordinate system type for the map's final geometry. Tje
         * default is CSTYPE_GEOCENTRIC.
         *
         * @param type
         *      Type of CS to use for the 3D map
         */
        void setCoordinateSystemType( const CoordinateSystemType& type );
       
        /**
         * Sets the scale factor for height-field values.
         *
         * @param scale
         *      Multiplier for heights; default = 1.0
         */
        void setVerticalScale( float scale );

        /**
         * Gets the scale factor for height-field values.
         */
        float getVerticalScale() const;

        /**
         * Gets the list of image tile source configs in this map.
         */
        SourceConfigList& getImageSourceConfigs();

        /**
         * Gets the list of image tile source configs in this map.
         */
        const SourceConfigList& getImageSourceConfigs() const;

        /**
         * Gets the list of elevation tile source configs in this map.
         */
        SourceConfigList& getHeightFieldSourceConfigs();

        /**
         * Gets the list of elevation tile source configs in this map.
         */
        const SourceConfigList& getHeightFieldSourceConfigs() const;

        /**
        *Gets the list of image TileSources in this Map
        */
        const osgEarth::TileSourceList& getImageSources() const {return _imageSources;}

        /**
        *Gets the list of image TileSources in this Map
        */
        osgEarth::TileSourceList& getImageSources() {return _imageSources;}

        /**
        *Gets the list of heightfield TileSources in this Map
        */
        const TileSourceList& getHeightFieldSources() const {return _heightFieldSources;}

        /**
        *Gets the list of image TileSources in this Map
        */
        TileSourceList& getHeightFieldSources() {return _heightFieldSources;}
        
        /**
         * Sets the skirt ratio to be used when creating height field tiles. This
         * is the ratio of the height of the tile "skirt" to the width of the tile.
         *
         * @param skirtRatio
         *      The skirt ratio; default = 0.02
         */
        void setSkirtRatio(float skirt_ratio);
        
        /**
         * Gets the skirt ratio to be used when creating height field tiles
         *
         * @return The skirt ratio
         */
        float getSkirtRatio() const;

        /**
         *Sets the sample ratio for height fields
         */
        void setSampleRatio(float sample_ratio);

        /**
         Gets the sample ratio for height fields
         */
        float getSampleRatio() const;

        /** 
         * Sets the hostname of a proxy server to use for all HTTP communications.
         */
        void setProxyHost( const std::string& host );

        /**
         * Gets the hostname of a proxy server to use for all HTTP communications.
         */
        const std::string& getProxyHost() const;

        /**
         * Sets the TCP port for proxy requests to the proxy host. Default is 8080.
         */
        void setProxyPort( unsigned short port );

        /** 
         * Gets the TCP port for proxy requests to the proxy host.
         */
        unsigned short getProxyPort() const;

        /**
         * Sets the minimum tile LOD range as a factor of the tile's radius.
         * The default value = 6.0.
         */
        void setMinTileRangeFactor( float factor );

        /**
         * Gets the minimum tile LOD range as a factor of the tile's radius.
         */
        float getMinTileRangeFactor() const;

        /**
         * Sets whether or not the map should be run exclusively off of the cache.
         * @param cacheOnly
         *       Whether or not the map should be only off of the cache.
         */
        void setCacheOnly(bool cacheOnly);

        /**
         * Gets whether or not the map should be run exclusively off of the cache.        
         * @returns
         *       Whether or not the map should be run in "offline" mode
         */
        bool getCacheOnly() const;

        /**
         * Gets whether or not to normalize terrain tile edges
         */
        bool getNormalizeEdges() const;

        /**
         *Sets whether or not to normalize terrain tile edges
         */
        void setNormalizeEdges(bool normalizeEdges);

        /**
         *Gets whether or not to apply the default layer combination logic using TexEnvCombine.
         */
        bool getCombineLayers() const;

        /**
         *Sets whether or not to apply the default layer combination logic using TexEnvCombine.
         *By setting this to false, the developer is assuming all control of the way that
         *the layers are combined using shaders, TexEnvCombine, etc.
         */
        void setCombineLayers(bool combineLayers);

        /*
        *Sets the absolute filename that the map was loaded from
        */
        void setFilename(const std::string &filename);

        /*
        *Gets the absolute filename that the map was loaded from
        */
        const std::string& getFilename() const;

        /*
        *Gets the cache config for the map
        */
        const CacheConfig& getCacheConfig() const;

        /*
        *Sets the cache config for the map
        */
        void setCacheConfig( const CacheConfig& cacheConfig);

        const ProfileConfig& getProfileConfig() const;
        void setProfileConfig( const ProfileConfig& profileConfig );

        /**
         * Gets or sets the global ReaderWriter options assocated with this map 
         * configuration
         */
        const osgDB::ReaderWriter::Options* getGlobalOptions() const;
        void setGlobalOptions( const osgDB::ReaderWriter::Options* options );

        /**
         *Gets the mutex that protects access to the TileSources
         */
        OpenThreads::ReadWriteMutex& getSourceMutex() const;

        /**
         *Gets the Profile of this Map
         */
        const Profile* getProfile() const;  

        /**
        * Returns true if the configuration used to create this Map was valid
        * and loaded as expected.
        */
        bool isOK() const;

        /**
        *Initializes the MapConfig.  Should be called after initial configuration is complete
        */
        void initialize();
    private:
        TileSource* createTileSource( const SourceConfig& sourceConfig );

        std::string _filename;
        std::string _name;
        CoordinateSystemType _model_cstype;
        float _vertical_scale;
        float _skirt_ratio;   
        float _sample_ratio;
        unsigned int _id;
        
        SourceConfigList _imageSourceConfigs;
        SourceConfigList _heightFieldSourceConfigs;

        TileSourceList _imageSources;
        TileSourceList _heightFieldSources;


        std::string _proxy_host;
        unsigned short _proxy_port;
        float _min_tile_range_factor;

        bool _cache_only;
        bool _normalize_edges;
        bool _combine_layers;

        CacheConfig _cache_config;
        ProfileConfig _profile_config;

        osg::ref_ptr<const Profile> _profile;

        //Protect access to the sources
        OpenThreads::ReadWriteMutex _sourceMutex;

        osg::ref_ptr<const osgDB::ReaderWriter::Options> _global_options;
    };


    /**
     * Reader or writes MapConfig objects to/from XML.
     */
    class OSGEARTH_EXPORT MapConfigReaderWriter
    {
    public:
        static bool readXml( const std::string& location, MapConfig& out_map );
        static bool readXml( std::istream& input, MapConfig& out_map );

        static bool writeXml( const std::string& location, const MapConfig& map );
        static bool writeXml( std::ostream& output, const MapConfig& map );
    };
};

#endif // OSGEARTH_MAP_CONFIG_H