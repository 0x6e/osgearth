/* -*-c++-*- */
/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph
 * Copyright 2008-2009 Pelican Ventures, Inc.
 * http://osgearth.org
 *
 * osgEarth is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */

#ifndef OSGEARTH_TILE_BUILDER_H
#define OSGEARTH_TILE_BUILDER_H 1

#include <osgEarth/Common>
#include <osgEarth/TileSource>
#include <osgEarth/MapConfig>
#include <osgEarth/Compositing>
#include <osgEarth/ElevationManager>
#include <osgDB/ReaderWriter>
#include <osgTerrain/Terrain>
#include <vector>

namespace osgEarth
{
    /**
     * Helper class that works around a bug in OSG pre-2.8.
     */
    class OSGEARTH_EXPORT EarthTerrain : public osgTerrain::Terrain
    {
    public:
        virtual const char* className() const { return "EarthTerrain"; }

        /** Get the TerrainTile for a given TileID. */
        osgTerrain::TerrainTile* getTileOverride(const osgTerrain::TileID& tileID)
        {
            OpenThreads::ScopedLock<OpenThreads::Mutex> lock(_mutex);

            TerrainTileMap::iterator itr = _terrainTileMap.find(tileID);
            if (itr == _terrainTileMap.end()) return 0;

            return itr->second;
        }
    };


    /**
     * TileBuilder is the main workhorse in osgEarth. It generates osg Nodes for
     * TileKeys.
     */
    class OSGEARTH_EXPORT TileBuilder : public osg::Referenced
    {
    public:
        /**
         * Creates a Node from the given MapConfig.  This allows you to programatically create a
         * MapConfig and create a paging scene graph out of it.
         */
        static osg::Node* readNode( MapConfig* map );


    public:
        /**
         * Factory method that constructs a TileBuilder instance given a
         * map configuration.
         */
        static TileBuilder* create(
            MapConfig* map,
            const osgDB::ReaderWriter::Options* global_options =NULL );

        /**
        *Gets the ID for this TileBuilder
        */
        unsigned int getId() const;

        /**
         * Creates the root node for a TileBuilder
         */
        osg::Node* createRootNode();

        /**
         * Creates a node graph for a given TileKey.
         */
        osg::Node* createNode( const TileKey* key );

        /**
         * Gets the map configuration with which this tile builder was created.
         */
        MapConfig* getMapConfig() const;

        /**
         * Gets the collection of image tile sources managed by this tile builder.
         */
        TileSourceList& getImageSources();
        const TileSourceList& getImageSources() const;

        /**
         * Gets the collection of height-field tile sources managed by thie tile builder.
         */
        TileSourceList& getHeightFieldSources();
        const TileSourceList& getHeightFieldSources() const;

        /**
         * Gets whether this tile builder is legally configured.
         */
        bool isOK() const;

        /**
         * Gets the "profile" of the map created by this tile builder. The profile defines
         * the geospatial projection, extents, and the tiling scheme.
         */
        const Profile* getMapProfile() const;

        GeoImage* createGeoImage(const TileKey* key, TileSource* source);

        //Registers the given TileBuilder with osgEarth.  This should not be called by user code
        static void registerTileBuilder(TileBuilder* tileBuilder, osg::Node *node);
        //Unregisters the given TileBuilder.  This should not be called by user code
        static void unregisterTileBuilder(unsigned int id);

        //Gets the registered TileBuilder by the TileBuilder ID
        static TileBuilder* getTileBuilderById(unsigned int id);

        //Gets the TileBuilder that is associated with the given node
        static TileBuilder* getTileBuilderByNode(osg::Node* node);

        /**
         *Gets the ElevationManager for this TileBuilder
         */
        ElevationManager* getElevationManager();

    protected:
        TileBuilder( 
            MapConfig* map, 
            const osgDB::ReaderWriter::Options* global_options );

        /**
         * Gets a pagedLOD child URI given a tile key.
         */
        std::string createURI( const TileKey* key );

        /**
        * Adds any appropriate child nodes to the given parent group for the given TileKey.
        * The implementation class must define this method.
        *
        * @param parent
        *        The parent osg::Group to add the children to
        * @param key
        *        The tilekey to generate children for
        * @returns
        *        True if all children were successfully added to the group, false otherwise
        */
        virtual bool addChildren( osg::Group* parent, const TileKey* key );

        /**
         * The implementation class must define this function, which creates one of
         * a child quadrant of a tile node.
         */
        virtual osg::Node* createQuadrant( const TileKey* key ) =0;

        /**
         * The implementing class must define this method to create a valid
         * CoordinateSystemNode that will top the scene graph.
         */
        virtual osg::CoordinateSystemNode* createCoordinateSystemNode() const =0;

    protected:

        typedef std::pair<osg::ref_ptr<GeoImage>, osg::ref_ptr<const TileKey> > ImageTileKeyPair;
        typedef std::vector<ImageTileKeyPair> ImageTileList;

        bool createValidImage(TileSource* tileSource, const TileKey *key, ImageTileKeyPair &imageTile);
        
	    osg::Matrixd getTransformFromExtents(double minX, double minY, double maxX, double maxY) const;

        // checks whether more data exists below the specified key's level of detail
        bool hasMoreLevels( const TileKey* key ) const;

        //Profile _mapProfile;
        //bool _profileComputed;

        unsigned int id;

        osg::ref_ptr<MapConfig> _map;
        TileSourceList _image_sources;
        TileSourceList _heightfield_sources;

        //Use observer_ptr so the TileBuilder does not prevent the main scene graph from being deleted
        osg::observer_ptr<osgEarth::EarthTerrain> _terrain;

        osg::ref_ptr<osgEarth::ElevationManager> _elevationManager;



    private:

        osg::ref_ptr<const Profile> _mapProfile;

        void initializeTileSources();

        TileSource* findTileSource( const std::string& name ) const;
        
        TileSource* loadSource(
            const MapConfig* mapConfig,
            const SourceConfig* source,
            const osgDB::ReaderWriter::Options* global_options);

        void addSources(
            const MapConfig* mapConfig,
            const SourceConfigList& from, 
            std::vector< osg::ref_ptr<TileSource> >& to,
            const osgDB::ReaderWriter::Options* global_options);

    };
};

#endif // OSGEARTH_TILE_BUILDER_H
