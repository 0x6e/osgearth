/* -*-c++-*- */
/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph
* Copyright 2008-2012 Pelican Mapping
* http://osgearth.org
*
* osgEarth is free software; you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>
*/
#ifndef OSGEARTH_OBJECT_INDEX_H
#define OSGEARTH_OBJECT_INDEX_H

#include <osgEarth/Common>
#include <osgEarth/ThreadingUtils>
#include <osg/Drawable>
#include <OpenThreads/Atomic>
#include <algorithm>

#define OSGEARTH_OBJECTID_EMPTY   (ObjectID)0u
#define OSGEARTH_OBJECTID_TERRAIN (ObjectID)1u

namespace osgEarth
{
    typedef unsigned ObjectID;

    /** 
     * Virutal interface class for building an object index.
     */
    template<typename T>
    class ObjectIndexBuilder
    {
    public:
        /**
         * Inserts the object into the index, and tags the drawable with its object id.
         * Returns the ID of the object.
         */
        virtual ObjectID tagDrawable(osg::Drawable* drawable, T* object) =0;

        /**
         * Inserts the object into the index, and tags all the drawalbes under the
         * specified node with the object ID. Returns the Object ID.
         */
        virtual ObjectID tagAllDrawables(osg::Node* node, T* object) =0;

        /**
         * Inserts the object into the index, and tags the Node with a uniform containing
         * the object id. Returns the Object ID.
         */
        virtual ObjectID tagNode(osg::Node* node, T* object) =0;
    };


    /**
     * Index for tracking objects in the scene graph using vertex
     * attributes and uniforms.
     */
    class OSGEARTH_EXPORT ObjectIndex : public osg::Referenced,
                                        public ObjectIndexBuilder<osg::Referenced>
    {
    public:
        /** constructs a new index */
        ObjectIndex();

        /**
         * Adds an object to the index, and returns a new globally unique
         * ID for that object. You can then use that UID to tag scene elements
         * with one of the tag* functions. If the object already exists in the
         * index, this method will return the UID assigned to it.
         */
        ObjectID insert(osg::Referenced* object);

        /**
         * Finds the object corresponding to a unique ID and places it in "output";
         * Returns true if found, false if not.
         */
        template<typename T>
        osg::ref_ptr<T> get(ObjectID id) const {
            Threading::ScopedMutexLock lock(_mutex);
            return dynamic_cast<T*>( getImpl(id) );
        }   

        /**
         * Removes the object corresponding the the unique ID form the index.
         */
        void remove(ObjectID id);

        /**
         * Removes a collection of objects from the index all at once.
         */
        template<typename ForwardIter>
        void remove(ForwardIter i0, ForwardIter i1) {
            _mutex.lock();
            for(typename ForwardIter i = i0; i != i1; ++i) removeImpl( *i );
            _mutex.unlock();
        }

        /**
         * The vertex attribute binding location to use when indexing geoemtry.
         * Warning: Changing this after tagging objects will cause undefined results.
         */
        void setAtrribLocation(int value);
        int getAttribLocation() const { return _attribLocation; }

        /**
         * The name of the uniform used to tag nodes when tagNode() is called.
         * Warning: Changing this after tagging objects will cause undefined results.
         */
        void setAttribUniformName(const std::string& name);
        const std::string& getAttribUniformName() const { return _attribUniformName; }


    public: // ObjectIndexBuilder<osg::Referenced>

        /**
         * Inserts the object into the index, and tags the drawable with its object id.
         * Returns the ID of the object.
         */
        ObjectID tagDrawable(osg::Drawable* drawable, osg::Referenced* object);

        /**
         * Inserts the object into the index, and tags all the drawalbes under the
         * specified node with the object ID. Returns the Object ID.
         */
        ObjectID tagAllDrawables(osg::Node* node, osg::Referenced* object);

        /**
         * Inserts the object into the index, and tags the Node with a uniform containing
         * the object id. Returns the Object ID.
         */
        ObjectID tagNode(osg::Node* node, osg::Referenced* object);


    public: // Raw tagging methods.

        /**
         * Tags the vertices in a drawable with the object identifier.
         */
        void tagDrawable(osg::Drawable* drawable, ObjectID id) const;

        /**
         * Tags the vertices in all Drawables until a node with the object identifier.
         */
        void tagAllDrawables(osg::Node* node, ObjectID id) const;

        /**
         * Tags a node with an object identifier. This simply puts a uniform on the
         * node and does NOT tag any actual vertices. This is only useful if you want
         * to tag an entire model and are not planning to merge geometries.
         */
        void tagNode(osg::Node* node, ObjectID id) const;


    protected:
        virtual ~ObjectIndex() { }
        
        typedef std::map<ObjectID, osg::ref_ptr<osg::Referenced> > IndexMap;
        //typedef std::map<osg::Referenced*, ObjectID>               ReverseIndexMap;

        IndexMap                 _index;
        //ReverseIndexMap          _reverseIndex;
        int                      _attribLocation;
        std::string              _attribUniformName;
        mutable Threading::Mutex _mutex;
        OpenThreads::Atomic      _idGen;

        ObjectID insertImpl(osg::Referenced*);
        void removeImpl(ObjectID id);
        osg::Referenced* getImpl(ObjectID id) const;
    };

} // namespace osgEarth

#endif // OSGEARTH_OBJECT_INDEX_H
