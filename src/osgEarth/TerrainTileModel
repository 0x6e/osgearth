/* -*-c++-*- */
/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph
 * Copyright 2008-2014 Pelican Mapping
 * http://osgearth.org
 *
 * osgEarth is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */
#ifndef OSGEARTH_TERRAIN_TILE_MODEL_H
#define OSGEARTH_TERRAIN_TILE_MODEL_H 1

#include <osgEarth/Common>
#include <osgEarth/TileKey>
#include <osgEarth/Layer>
#include <osgEarth/Revisioning>
#include <osgEarth/MapInfo>
#include <osgEarth/Locators>
#include <osgEarth/HeightFieldUtils>
#include <osgEarth/TileKeyDataStore>
#include <osg/Texture>
#include <osg/Matrix>

namespace osgEarth
{
    class TerrainTileLayerModel;

    /**
     * Data model backing an individual terrain tile.
     */
    class OSGEARTH_EXPORT TerrainTileModel : public osg::Referenced
    {
    public:
        enum LayerType
        {
            LAYER_IMAGE,         // imagery or other visible raster (vec4)
            LAYER_ELEVATION,     // edge-matched heightfield data (32-bit float)
            LAYER_NORMAL,        // surface normal/curvature data (vec4)
            LAYER_CUSTOM         // custom raster that an extension will deal with
        };

    public:
        typedef std::vector<osg::ref_ptr<TerrainTileLayerModel> > LayerVector;

    public:
        /** Constructor */
        TerrainTileModel(
            const TileKey&  key,
            const Revision& revision);

        /** Map model revision from which this model was created */
        const Revision& getRevision() const { return _revision; }

        /** TileKey corresponding to this model */
        const TileKey& getKey() const { return _key; }

        /** Layers comprising this tile model. */
        LayerVector& layers() { return _layers; }
        const LayerVector& layers() const { return _layers; }

        /** Find the first layer of a type */
        TerrainTileLayerModel* getLayer(LayerType type);
        const TerrainTileLayerModel* getLayer(LayerType type) const;

        /** Find the first layer with a matching name */
        TerrainTileLayerModel* getLayer(const std::string& name);
        const TerrainTileLayerModel* getLayer(const std::string& name) const;

        /** Find the layer with a matching layer uid */
        TerrainTileLayerModel* getLayer(const UID& layerUID);
        const TerrainTileLayerModel* getLayer(const UID& layerUID) const;

        /** Height field neighborhood surrounding the tile */
        /** TODO: does this need to be in the model itself? probably not */
        HeightFieldNeighborhood& heightFields() { return _heightFields; }
        const HeightFieldNeighborhood& heightFields() const { return _heightFields; }

    protected:
        TileKey                 _key;
        Revision                _revision;
        LayerVector             _layers;
        HeightFieldNeighborhood _heightFields;
    };

    /**
     * Data store that references TerrainTileModel by TileKey.
     */
    typedef TileKeyDataStore<const TerrainTileModel> TerrainTileModelStore;


    /**
     * Data model backing an individual layer of a terrain tile.
     */
    class OSGEARTH_EXPORT TerrainTileLayerModel : public osg::Referenced
    {
    public:
        /** Constructor - type only */
        TerrainTileLayerModel(
            TerrainTileModel::LayerType type);

        /** Constructor - name and type */
        TerrainTileLayerModel(
            const std::string&          name,
            TerrainTileModel::LayerType type);

        /** Name of this layer (might be empty) */
        const std::string& getName() const { return _name; }

        /** Type of data in this layer */
        const TerrainTileModel::LayerType getType() const { return _type; }

        /** Source layer */
        void setLayer(Layer* layer) { _layer = layer; }
        bool lockLayer(osg::ref_ptr<Layer>& layer) const { return _layer.lock(layer); }

        /** Texture to use for rendering this layer */
        void setTexture(osg::Texture* texture) { _texture = texture; }
        osg::Texture* getTexture() const { return _texture.get(); }

        /** Texture matrix to scale/bias the texture for the corresponding tile key */
        void setMatrix(osg::RefMatrixf* matrix) { _matrix = matrix; }
        osg::RefMatrixf* getMatrix() const { return _matrix.get(); }

    protected:
        virtual ~TerrainTileLayerModel() { }

        std::string                   _name;
        TerrainTileModel::LayerType   _type;
        osg::ref_ptr<osg::Texture>    _texture;
        osg::ref_ptr<osg::RefMatrixf> _matrix;
        osg::observer_ptr<Layer>      _layer;
    };
}

#endif // OSGEARTH_TERRAIN_TILE_MODEL_H
