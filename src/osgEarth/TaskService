/* -*-c++-*- */
/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph
 * Copyright 2008-2009 Pelican Ventures, Inc.
 * http://osgearth.org
 *
 * osgEarth is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */
#ifndef OSGEARTH_TASK_SERVICE
#define OSGEARTH_TASK_SERVICE 1

#include <osgEarth/Common>
#include <osgEarth/MapLayer>
#include <osgEarth/HTTPClient>
#include <OpenThreads/Thread>
#include <OpenThreads/Condition>
#include <osg/Referenced>
#include <queue>
#include <list>

namespace osgEarth
{
    class OSGEARTH_EXPORT TaskProgress : public osg::Referenced
    {
    public:
        TaskProgress() : _canceled(false) { }
        void cancel() { _canceled = true; }
        bool isCanceled() const { return _canceled; }
    private:
        bool _canceled;
    };

    class OSGEARTH_EXPORT TaskRequest : public osg::Referenced
    {
    public:
        enum State {
            STATE_IDLE,
            STATE_PENDING,
            STATE_IN_PROGRESS,
            STATE_COMPLETED,
            STATE_CANCELED
        };
    public:
        TaskRequest( float priority =0.0f );

        // the actual task code
        virtual void operator()( TaskProgress* progress ) =0;

        void run();
        void cancel();
        bool isIdle() const { return _state == STATE_IDLE; }
        bool isPending() const { return _state == STATE_PENDING; }
        bool isCompleted() const { return _state == STATE_COMPLETED; }
        bool isCanceled() const;
        void setPriority( float value ) { _priority = value; }
        float getPriority() const { return _priority; }
        State getState() const { return _state; }
        void setState(State s) { _state = s; }
        void setStamp(int stamp) { _stamp = stamp; }
        int getStamp() const { return _stamp; }
        osg::Referenced* getResult() const { return _result.get(); }

    protected:
        float _priority;
        bool _canceled;
        State _state;
        int _stamp;
        osg::ref_ptr<osg::Referenced> _result;
        osg::ref_ptr<TaskProgress> _progress;
    };

    typedef std::list< osg::ref_ptr<TaskRequest> > TaskRequestList;

    class TaskRequestQueue : public osg::Referenced
    {
    public:
        TaskRequestQueue();

        void add( TaskRequest* request );
        TaskRequest* get();
        void shutdown();
        void setStamp( int value ) { _stamp = value; }
        int getStamp() const { return _stamp; }

    private:
        TaskRequestList _requests;
        OpenThreads::Mutex _mutex;
        OpenThreads::Condition _cond;
        bool _done;
        int _stamp;
    };
    
    struct TaskThread : public OpenThreads::Thread
    {
        TaskThread( TaskRequestQueue* queue );
        void run();
        void shutdown();

    private:
        osg::ref_ptr<TaskRequestQueue> _queue;
        osg::ref_ptr<TaskRequest> _request;
        HTTPClient _httpClient;
        bool _done;
    };

    class OSGEARTH_EXPORT TaskService : public osg::Referenced
    {
    public:
        TaskService( int numThreads =4 );

        void add( TaskRequest* request );

        void setStamp( int stamp );

    private:
        typedef std::list<TaskThread*> TaskThreads;
        TaskThreads _threads;
        osg::ref_ptr<TaskRequestQueue> _queue;

        virtual ~TaskService();
    };
}

#endif // OSGEARTH_TASK_SERVICE

