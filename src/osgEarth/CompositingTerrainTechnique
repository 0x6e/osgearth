/* -*-c++-*- */
/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph
* Copyright 2008-2009 Pelican Ventures, Inc.
* http://osgearth.org
*
* osgEarth is free software; you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>
*/

#ifndef OSGTERRAIN_COMPOSITING_TERRAIN_TECHNIQUE
#define OSGTERRAIN_COMPOSITING_TERRAIN_TECHNIQUE 1

#include <osg/MatrixTransform>
#include <osg/Geode>
#include <osg/Geometry>
#include <osg/Texture2DArray>
#include <osg/Version>

#include <osgTerrain/TerrainTechnique>
#include <osgTerrain/Locator>
#include <osgEarth/Export>
#include <osgEarth/Progress>
#include <osgEarth/ThreadingUtils>

#include <osgEarth/EarthTerrainTechnique>

namespace osgEarth
{
    /**
     * A terrain technique that uses a single texture unit by compositing image layer textures
     * on the GPU.
     * 
     * This technique works by creating a single "mosaic" texture and copying each image layer's 
     * texture into that mosaic. It then creates a uniform array that conveys the relative offset
     * and scale information of each sub-texture to a shader. The shader then composites the
     * approprate mosaic texels on the GPU.
     *
     * Limitations:
     *
     * This technique is limited by the maximum texture size your GPU will support, since it 
     * creates a single mosaic texture. For example, if your GPU's max texture size is 2048,
     * this technique can support 64 256-pixel layers.
     *
     * This technique does not work with the specialized MercatorLocator.
     */
    class OSGEARTH_EXPORT CompositingTerrainTechnique : public ExtendedTerrainTechnique
    {
    public:
        CompositingTerrainTechnique( osgTerrain::Locator* locator =0L );

        CompositingTerrainTechnique(const CompositingTerrainTechnique&,const osg::CopyOp& copyop=osg::CopyOp::SHALLOW_COPY);
        META_Object(osgEarth, CompositingTerrainTechnique);


    public: /* overrides */
#if OSG_MIN_VERSION_REQUIRED(2,9,8)        
        virtual void init(int dirtyMask, bool assumeMultiThreaded);
#else
        virtual void init();
#endif

        virtual void init( bool swapNow, ProgressCallback* progress );

        // returns TRUE if a swap occurred and a new subgraph is now in place.
        bool swapIfNecessary();

        virtual osgTerrain::Locator* computeMasterLocator();

        virtual osg::Vec3d computeCenterModel(osgTerrain::Locator* masterLocator);

        virtual void generateGeometry(osgTerrain::Locator* masterLocator, const osg::Vec3d& centerModel);

        //virtual void applyColorLayers();

        //virtual void applyTransparency();

        //virtual void smoothGeometry();

        virtual void update(osgUtil::UpdateVisitor* nv);

        virtual void cull(osgUtil::CullVisitor* nv);

        /** Traverse the terrain subgraph.*/
        virtual void traverse(osg::NodeVisitor& nv);

        virtual void cleanSceneGraph();

    public:

        inline Threading::ReadWriteMutex& getMutex();

        /**
        * Sets a factor by which to scale elevation height values. By default, this object
        * will get the vertical scale from the osgTerrain::Terrain with which the tile is
        * associated. Setting this value overrides that (or sets it if there is no terrain).
        */
        void setVerticalScaleOverride( float value );

        /**
        * Gets the overriden vertical scale value.
        */
        float getVerticalScaleOverride() const;

        /**
         * Sets whether to try to optimize the triangle orientation based on the elevation values.
         *  If false, 
         */
        void setOptimizeTriangleOrientation(bool optimizeTriangleOrientation);
        bool getOptimizeTriangleOrientation() const;

        /** If State is non-zero, this function releases any associated OpenGL objects for
        * the specified graphics context. Otherwise, releases OpenGL objects
        * for all graphics contexts. */
        virtual void releaseGLObjects(osg::State* = 0) const;

    protected:

        void calculateSampling( int& out_rows, int& out_cols, double& out_i, double& out_j );

    private:

        virtual ~CompositingTerrainTechnique();

        struct BufferData
        {
            osg::ref_ptr<osg::MatrixTransform>  _transform;
            osg::ref_ptr<osg::Geode>            _geode;
            osg::ref_ptr<osg::Geode>            _simpleGeode;
            osg::ref_ptr<osg::Geometry>         _surface;
            osg::ref_ptr<osg::Geometry>         _skirt;
        };

        OpenThreads::Mutex                  _writeBufferMutex;

        unsigned int _currentReadOnlyBuffer;
        unsigned int _currentWriteBuffer;
        BufferData _bufferData[2];

        void swapBuffers();

        inline BufferData& getReadOnlyBuffer() { return _bufferData[_currentReadOnlyBuffer]; }
        inline BufferData& getWriteBuffer() { return _bufferData[_currentWriteBuffer]; }

        void clearBuffer( int which );

        osg::Vec3d _lastCenterModel;
        float _verticalScaleOverride;

        osg::ref_ptr<osgTerrain::Locator> _masterLocator;

        bool _swapPending;
        int _initCount;

        bool _optimizeTriangleOrientation;

    private:

        struct LayerTexRegion
        {
            LayerTexRegion();

            // transforms image-space tex coords to composite-space tex coords.
            osg::Vec2 transform( float x, float y ) const;

            // pixel coordinates of layer in the composite image:
            int _px, _py, _pw, _ph;

            // texture coordinates of layer in the composite image:
            float _tx, _ty, _tw, _th;

            // texture scale and offset for this region:
            float _xoffset, _yoffset, _xscale, _yscale;

            // 0..1
            float _opacity;
        };

        typedef std::vector<LayerTexRegion> LayerTexRegionList;
        
        void initShaders();
        //void applyTexture();

        //LayerTexRegionList         _layerTexRegions;
        osg::ref_ptr<osg::Program> _compositeProgram;
        bool                       _attachedProgram;

        //bool generateCompositeImage( osg::ref_ptr<osg::Image>& out_image, LayerTexRegionList& out_regions );
        // osg::ref_ptr<osg::Image>   _compositeImage;

        bool generateCompositeTexture();
            //osg::ref_ptr<osg::Texture>& out_tex,
            //int& out_width,
            //int& out_height,
            //LayerTexRegionList& out_regions );

        //osg::ref_ptr<osg::Texture> _composite;
        //int _compositeWidth, _compositeHeight;
    };

}

#endif // OSGTERRAIN_COMPOSITING_TERRAIN_TECHNIQUE
