/* -*-c++-*- */
/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph
 * Copyright 2008-2009 Pelican Ventures, Inc.
 * http://osgearth.org
 *
 * osgEarth is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */

#ifndef OSGEARTH_MAP_ENGINE_H
#define OSGEARTH_MAP_ENGINE_H 1

#include <osgEarth/MapConfig>
#include <osgEarth/Layer>
#include <osgEarth/TileSource>
#include <osgEarth/Compositing>

#include <OpenThreads/ReadWriteMutex>
#include <osgDB/ReaderWriter>
#include <osgTerrain/Terrain>
#include <osg/CoordinateSystemNode>
#include <vector>

namespace osgEarth
{
    /**
     * Helper class that works around a bug in OSG pre-2.8.
     */
    class EarthTerrain : public osgTerrain::Terrain
    {
    public:
        virtual const char* className() const { return "EarthTerrain"; }

        /** Get the TerrainTile for a given TileID. */
        osgTerrain::TerrainTile* getTileOverride(const osgTerrain::TileID& tileID)
        {
            OpenThreads::ScopedLock<OpenThreads::Mutex> lock(_mutex);

            TerrainTileMap::iterator itr = _terrainTileMap.find(tileID);
            if (itr == _terrainTileMap.end()) return 0;

            return itr->second;
        }

        typedef std::vector< osg::ref_ptr<osgTerrain::TerrainTile> > TerrainTileList;

        void getTerrainTiles( TerrainTileList &tiles )
        {
            OpenThreads::ScopedLock<OpenThreads::Mutex> lock(_mutex);

            for(TerrainTileSet::iterator itr = _terrainTileSet.begin();
                itr != _terrainTileSet.end();
                ++itr)
            {
                tiles.push_back( (*itr) );
            }

            osg::notify(osg::NOTICE) << "TileSet has " << _terrainTileSet.size() << std::endl;
        }
    };


    /**
     * MapEngine is the main workhorse in osgEarth. It implements the public Map
     * interface and generates osg Nodes for TileKeys.
     */
    class OSGEARTH_EXPORT MapEngine : public osg::Referenced
    {
    public:
        /**
         * Gets the ID for this Map
         */
        unsigned int getId() const;

        /**
         * Creates a node graph for a given TileKey.
         */
        osg::Node* createNode( const TileKey* key );

        /**
         * Gets the map configuration with which this map was created.
         */
        const MapConfig& getMapConfig() const;

        /**
         * Gets the "profile" of the map. The profile defines
         * the geospatial projection, extents, and the tiling scheme.
         */
        const Profile* getProfile() const;

        /**
         * Creates a georeferenced image corresponding to a tile key.
         */
        GeoImage* createGeoImage(const TileKey* key, TileSource* source);


        bool isCached(const TileKey* key);


        //Initializes the scene graph for this Map after it has been contstructed
        virtual osg::Node* initialize();

        
        /**
         * Returns true if the configuration used to create this Map node was valid
         * and loaded as expected.
         */
        bool isOK() const;

        /**
         * Tells the map to update the display because a layer has new settings.
         */
        void dirtyLayers();

        /**
         * Adds the given layer to the end of the Layer list
         */
        void addLayer( Layer* layer );

        /**
         * Removes the given layer from this Map's Layer List.
         */
        void removeLayer( Layer* layer );

        /**
         * Moves the given layer to the given position in this Map's Layer list.
         */
        void moveLayer( Layer* layer, int position );

        /**
         * Gets the number of layers contained in this Map
         */
        unsigned int getNumLayers() const;

        /**
         * Gets the Layer at the given position in this Map.
         */
        Layer* getLayer( unsigned int i ) const;

        /**
         * Get a list of all ImageLayers in this Map.  The ImageLayers will be returned in
         * the order in which they appear in the Layer list
         */
        void getImageLayers( ImageLayerList& layers ) const;

        /**
         * Get a list of all ElevationLayers in this Map.  The ElevationLayers will be
         * returned in the order in which they appear in the Layer list
         */
        virtual void getElevationLayers( ElevationLayerList& layers ) const;

        /**
         * Creates a TileSource with the given SourceConfig
         */
        TileSource* createTileSource( const SourceConfig& sourceConfig );


    public: // static methods        

        //Registers the given Map with osgEarth.  This should not be called by user code
        static void registerMapEngine( MapEngine* map_engine );

        //Unregisters the given Map.  This should not be called by user code
        static void unregisterMapEngine( unsigned int id );

        //Gets the registered Map by the Map ID
        static MapEngine* getMapEngineById( unsigned int id );


    protected:

        MapEngine( const MapConfig& map );

        virtual ~MapEngine();

        /**
         * Gets a pagedLOD child URI given a tile key.
         */
        std::string createURI( const TileKey* key );

        /**
        * Adds any appropriate child nodes to the given parent group for the given TileKey.
        * The implementation class must define this method.
        *
        * @param parent
        *        The parent osg::Group to add the children to
        * @param key
        *        The tilekey to generate children for
        * @returns
        *        True if all children were successfully added to the group, false otherwise
        */
        virtual bool addChildren( osg::Group* parent, const TileKey* key );

        /**
         * The implementation class must define this function, which creates one of
         * a child quadrant of a tile node.
         */
        virtual osg::Node* createQuadrant( const TileKey* key ) =0;

        /**
         * The implementing class must define this method to create a valid
         * CoordinateSystemNode that will top the scene graph.
         */
        virtual osg::CoordinateSystemNode* createCoordinateSystemNode() const =0;

    protected:
        GeoImage* createValidGeoImage(TileSource* tileSource, const TileKey* key);
        
	    osg::Matrixd getTransformFromExtents(double minX, double minY, double maxX, double maxY) const;

        // checks whether more data exists below the specified key's level of detail
        bool hasMoreLevels( const TileKey* key );

        unsigned int id;

        MapConfig _mapConfig;

        //Use observer_ptr so the Map does not prevent the main scene graph from being deleted
        std::vector< osg::observer_ptr<osgEarth::EarthTerrain> > _terrains;

        osg::ref_ptr< const osgDB::ReaderWriter::Options > _options;

        osg::HeightField* createHeightField( const TileKey* key, bool fallback );

        osg::HeightField* createEmptyHeightField( const TileKey* key );

        OpenThreads::ReadWriteMutex& getLayersMutex();

        friend class Layer;



    private:


        osg::ref_ptr<const Profile> _profile;

        void initializeLayers();

        void addSources(
            const MapConfig& mapConfig,
            const SourceConfigList& from, 
            std::vector< osg::ref_ptr<TileSource> >& to );

        //The list of layers contained by the map;        
        LayerList _layers;
        OpenThreads::ReadWriteMutex _layersMutex;

        void updateUniforms();

        osg::ref_ptr<osg::StateSet> uniformStateSet;
        //osg::ref_ptr<osg::CoordinateSystemNode> csn;

        static OpenThreads::ReentrantMutex s_mapEngineCacheMutex;
        friend class Map;
    };
}


#endif // OSGEARTH_MAP_IMPLEMENTATION_H
