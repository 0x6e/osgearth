/* -*-c++-*- */
/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph
* Copyright 2008-2012 Pelican Mapping
* http://osgearth.org
*
* osgEarth is free software; you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>
*/
#ifndef OSGEARTH_SPLAT_SHADERS
#define OSGEARTH_SPLAT_SHADERS 1

namespace
{
    /**
     * NOTE: tokens of the form "$TOKEN" will be replaced at run time.
     */
    const char* splatVertexShader =
        "#version 120\n"
        GLSL_DEFAULT_PRECISION_FLOAT "\n"

        // from the terrain engine
        "uniform vec4 oe_tile_key; \n"
        "varying vec4 oe_layer_tilec; \n"

        "uniform float oe_splat_L0; \n"
        
        "uniform mat4 $COVERAGE_TEXMAT_UNIFORM; \n"

        "varying float oe_splat_distance; \n"
        "varying vec2 oe_splat_tileScaleBias; \n"
        "varying vec2 oe_splat_covtc; \n"

        "int oe_splat_ipow(in int x, in int y) { \n"
        "   int r = 1; \n"
        "   while( y > 0 ) { \n"
        "       r *= x; \n"
        "       --y; \n"
        "   } \n"
        "   return r; \n"
        "}\n"

        "#define L0SPLIT 5.0\n"

        "void oe_splat_vertex(inout vec4 VertexVIEW) \n"
        "{ \n"
        // We can only scale the splatting texture coordinates so much in 
        // single-precision space, hence the need for the L0. There is likely
        // a way to reduce this to one uniform; i.e. automatically set L0 to
        // be max(tile_key.z, 7) and adjust the scale factor accordingly.

        "    float L0 = 0.0; \n"
        //"    float L0 = oe_tile_key.z >= L0SPLIT ? L0SPLIT : 0.0; \n"

        "    float dL = oe_tile_key.z - L0; \n" //oe_splat_L0; \n"
        "    float twoPowDeltaL = float(oe_splat_ipow(2, int(abs(dL)))); \n"
        "    float factor = dL >= 0.0 ? twoPowDeltaL : 1.0/twoPowDeltaL; \n"

        "    vec2 a = floor(oe_tile_key.xy / factor); \n"
        "    vec2 b = a * factor; \n"
        "    vec2 c = (a+1.0) * factor; \n"
        "    vec2 offset = (oe_tile_key.xy-b)/(c-b); \n"
        "    vec2 scale = vec2(1.0/factor); \n"
        
        // calculate the splat texture coordinates based on the scale calculation.
        "    oe_splat_tileScaleBias = (oe_layer_tilec.st * scale) + offset; \n"
        "    oe_splat_distance = -VertexVIEW.z/VertexVIEW.w; \n"
        
        // calculate the coverage sampling coordinates. The matrix accounts for
        // any super-sampling that might be in effect that the current LOD.
        "    oe_splat_covtc = ($COVERAGE_TEXMAT_UNIFORM * oe_layer_tilec).st;\n"
        "} \n";


    const char* splatFragmentShader =
        //"#version " GLSL_VERSION_STR "\n"
        "#version 120\n"
        "#extension GL_EXT_texture_array : enable\n"
        GLSL_DEFAULT_PRECISION_FLOAT "\n"
        
        "varying vec4 oe_layer_tilec; \n"

        "uniform vec4 oe_tile_key; \n"

        "varying float oe_splat_distance; \n"
        "varying vec2 oe_splat_tileScaleBias; \n"
        "varying vec2 oe_splat_covtc; \n"

        "uniform float oe_splat_intensity; \n"
        "uniform float oe_splat_warp; \n"
        "uniform float oe_splat_samples; \n"

        "uniform sampler2D oe_coverage_tex; \n"
        "uniform sampler2DArray oe_splat_tex; \n"

        "float oe_splat_noise2(in vec2);\n"

        // creates a texel by sampling the splatting texture based
        // on the coverage value. (Generated in code)
        "vec4 oe_splat_getTexel(in float value, in vec2 splat_tc);\n"

        "float oe_splat_rand(vec2 co){\n"
        "   return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n"
        "}\n"
                
        // rotates a vector.
        "vec2 oe_splat_rot(vec2 p, float a) { \n"
        "    float s = sin(a), c = cos(a); \n"
        "    return vec2(p.x*c - p.y*s, p.x*s + p.y*c); \n"
        "}\n"        
        
        // permutation vectors for the warper.
        // highly unlikely that we will use more than 2 or 3 of these in practice.
        "#define OE_SPLAT_MAX_SAMPLES 15\n"
        "const vec2 oe_splat_warp_vecs[OE_SPLAT_MAX_SAMPLES] = vec2[]( vec2( -0.942016, -0.399062 ), vec2( 0.845586, -0.768907 ), vec2( 0.344959, 0.293878 ), vec2( -0.915886, 0.457714 ), vec2( -0.815442, -0.879125 ), vec2( -0.382775, 0.276768 ), vec2( 0.974844, 0.756484 ), vec2( 0.443233, -0.975116 ), vec2( 0.53743, -0.473734 ), vec2( -0.264969, -0.41893 ), vec2( 0.791975, 0.190909 ), vec2( -0.241888, 0.997065 ), vec2( -0.8141, 0.914376 ), vec2( 0.199841, 0.786414 ), vec2( 0.143832, -0.141008 )); \n"


        // Applies the warping factor to the coverage sampling coordinates
        // to mitigate blockiness.
        "vec2 oe_splat_warp_texcoord(int sample, in vec2 splat_tc, in float scale)\n"
        "{\n"
        "    vec2 v = oe_splat_warp_vecs[sample]; \n"
        "    vec2 seed = splat_tc + v*oe_splat_warp; \n"
        "    float n1 = oe_splat_noise2(seed*(scale-1.0)); \n"
        "    vec2 tc = oe_splat_covtc + n1*v*oe_splat_warp; \n"

        "    tc = clamp(tc, 0.0, 1.0);\n"
        "    return tc;\n"
        "}\n"

        // Single-sample splatter.
        "vec4 oe_splat_single_texel(in vec2 splat_tc, in float scale) \n"
        "{ \n"
        "    vec2 warped_tc = oe_splat_warp_texcoord(0, splat_tc, scale);\n"
        "    vec4 cov = texture2D(oe_coverage_tex, warped_tc); \n"
        "    return oe_splat_getTexel(cov.r*255.0, splat_tc); \n"
        "} \n"

        // Multi-sample splatter.
        "vec4 oe_splat_multi_texel(in float samples, in vec2 splat_tc, in float scale) \n"
        "{ \n"
        "    float step = samples > 1.0 ? 2.0/(samples-1.0) : 2.0; \n"
        "    vec4 texel = vec4(0.0, 0.0, 0.0, 1.0);\n"
        
        "    int isamples = int(samples); \n"
        "    for(int sample=0; sample<isamples; ++sample) \n"
        "    {\n"
        "        vec2 warped_tc = oe_splat_warp_texcoord(sample, splat_tc, scale);\n"
        "        vec4 cov = texture2D(oe_coverage_tex, warped_tc); \n"
        "        vec4 tex = oe_splat_getTexel(cov.r*255.0, splat_tc); \n"
        "        texel.rgb += tex.rgb;\n"
        "    }\n"

        "    texel.rgb /= samples; \n"
        "    return texel; \n"
        "} \n"

        // Main entry point for fragment shader.
        "void oe_splat_fragment(inout vec4 color) \n"
        "{ \n"
        //"    if (oe_tile_key.z < oe_splat_L0) return;\n"

        "    float scaleOffset = 0.0; \n" //oe_tile_key.z >= 8.0 ? -7.0 : 0.0; \n"

        // Quantize the sample count.
        "    float isamples = min(ceil(oe_splat_samples), OE_SPLAT_MAX_SAMPLES-1.0); \n"

        // View Range and Scale factor mappings.
        "#define RANGE_COUNT 7\n"
        "    const float ranges[RANGE_COUNT] = float[](  0.0, 4000.0, 30000.0, 150000.0, 300000.0, 1000000.0, 5000000.0 );\n"
        "    const float scales[RANGE_COUNT] = float[]( 16.0,   14.0,    12.0,      9.0,      8.0,       6.0,       2.0 ); \n"

        // Choose the best range based on distance to camera.
        "    float d = clamp(oe_splat_distance, ranges[0], ranges[RANGE_COUNT-1]); \n"

        "    vec4 texel; \n"

        "    for(int i=0; i<RANGE_COUNT-1; ++i) \n"
        "    { \n"
        "        if ( d >= ranges[i] && d <= ranges[i+1] ) \n"
        "        { \n"
        "            float scale0 = scales[i] + scaleOffset; \n"
        "            float scale1 = scales[i+1] + scaleOffset; \n"

        "            vec2 splat_tc0 = pow(2.0, scale0-1.0) * oe_splat_tileScaleBias;\n"
        "            vec4 texel0 = oe_splat_samples <= 1.0 ? \n"
        "               oe_splat_single_texel(splat_tc0, scale0) : \n"
        "               oe_splat_multi_texel(isamples, splat_tc0, scale0); \n"

        "            vec2 splat_tc1 = pow(2.0, scale1-1.0) * oe_splat_tileScaleBias;\n"
        "            vec4 texel1 = oe_splat_samples <= 1.0 ? \n"
        "               oe_splat_single_texel(splat_tc1, scale1) : \n"
        "               oe_splat_multi_texel(isamples, splat_tc1, scale1); \n"

        "            float r = (d-ranges[i])/(ranges[i+1]-ranges[i]); \n"
        "            texel = mix(texel0, texel1, r); \n"

        "            break; \n"
        "        }\n"
        "    } \n"

        "    color = mix(color, texel, oe_splat_intensity*texel.a); \n"
        "}\n";
}

#endif // OSGEARTH_SPLAT_SHADERS