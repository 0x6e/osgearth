/* -*-c++-*- */
/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph
* Copyright 2008-2012 Pelican Mapping
* http://osgearth.org
*
* osgEarth is free software; you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>
*/
#ifndef OSGEARTH_SPLAT_SHADERS
#define OSGEARTH_SPLAT_SHADERS 1

namespace
{
    /**
     * NOTE: tokens of the form "$TOKEN" will be replaced at run time.
     */
    const char* splatVertexShader =
        "#version " GLSL_VERSION_STR "\n"
        GLSL_DEFAULT_PRECISION_FLOAT "\n"

        // from the terrain engine
        "uniform vec4 oe_tile_key; \n"
        "varying vec4 oe_layer_tilec; \n"

        "uniform float oe_splat_L0; \n"
        "uniform float oe_splat_scale; \n"
        "varying vec2 oe_splat_tc; \n"
        
        "uniform mat4 $COVERAGE_TEXMAT_UNIFORM; \n"
        "varying vec2 oe_splat_covtc; \n"

        "int oe_splat_ipow(in int x, in int y) { \n"
        "   int r = 1; \n"
        "   while( y > 0 ) { \n"
        "       r *= x; \n"
        "       --y; \n"
        "   } \n"
        "   return r; \n"
        "}\n"

        "void oe_splat_vertex(inout vec4 VertexVIEW) \n"
        "{ \n"
        // We can only scale the splatting texture coordinates so much in 
        // single-precision space, hence the need for the L0. There is likely
        // a way to reduce this to one uniform; i.e. automatically set L0 to
        // be max(tile_key.z, 7) and adjust the scale factor accordingly.
        "    float dL = oe_tile_key.z - oe_splat_L0; \n"
        "    float twoPowDeltaL = float(oe_splat_ipow(2, int(abs(dL)))); \n"
        "    float factor = dL >= 0.0 ? twoPowDeltaL : 1.0/twoPowDeltaL; \n"

        "    vec2 a = floor(oe_tile_key.xy / factor); \n"
        "    vec2 b = a * factor; \n"
        "    vec2 c = (a+1.0) * factor; \n"
        "    vec2 offset = (oe_tile_key.xy-b)/(c-b); \n"
        "    vec2 scale = vec2(1.0/factor); \n"

        // calculate the splat texture coordinates based on the scale calculation.
        "    float tscale = pow(2.0, oe_splat_scale-1.0); \n"
        "    oe_splat_tc = tscale * ((oe_layer_tilec.st * scale) + offset); \n"
        
        // calculate the coverage sampling coordinates. The matrix accounts for
        // any super-sampling that might be in effect that the current LOD.
        "    oe_splat_covtc = ($COVERAGE_TEXMAT_UNIFORM * oe_layer_tilec).st;\n"
        "} \n";


    const char* splatFragmentShader =
        "#version " GLSL_VERSION_STR "\n"
        "#extension GL_EXT_texture_array : enable\n"
        GLSL_DEFAULT_PRECISION_FLOAT "\n"
        
        "varying vec4 oe_layer_tilec; \n"

        "uniform vec4 oe_tile_key; \n"
        "varying vec2 oe_splat_tc; \n"
        "varying vec2 oe_splat_covtc; \n"

        "uniform float oe_splat_L0; \n"
        "uniform float oe_splat_scale; \n"
        "uniform float oe_splat_intensity; \n"
        "uniform sampler2D oe_coverage_tex; \n"
        "uniform sampler2DArray oe_splat_tex; \n"

        "uniform float oe_splat_warp;\n"
        
        "float oe_splat_noise_circle(in vec2);\n"
        "float oe_splat_noise2(in vec2);\n"

        "vec4 oe_splat_getTexel(in float index, in vec2 splat_tc);\n" // generated in code

        "vec2 oe_splat_warp_texcoord(in float q)\n"
        "{\n"
        "    vec2 sp2 = oe_splat_tc + q; \n"
        "    sp2 = mod(sp2, 1.0); \n"
        "    float n1 = oe_splat_noise2(sp2*oe_splat_scale);\n"
        "    vec2 tc = oe_splat_covtc;\n"
        "    tc += n1*oe_splat_warp;\n"
        "    tc = clamp(tc, 0.0, 1.0);\n"
        "    return tc;\n"
        "}\n"

        "void oe_splat_fragment(inout vec4 color) \n"
        "{ \n"
        "    if (oe_tile_key.z < oe_splat_L0) return;\n"

        //"    float n1 = oe_splat_noise2(oe_splat_tc.st*oe_splat_scale);\n"
        //"    float n2 = oe_splat_noise2(oe_splat_tc.ts*oe_splat_scale);\n"
        //"    vec2 c2 = oe_splat_covtc;\n"
        //"    c2 = mod(c2,1.0);\n"
        //"    c2.x += n1*oe_splat_warp;\n"
        //"    c2.y += n2*oe_splat_warp;\n"
        //"    c2 = clamp(c2, 0.0, 1.0);\n"

        "    vec2 c2 = oe_splat_warp_texcoord(0.0);\n"
        "    vec4 cov = texture2D(oe_coverage_tex, c2); \n"
        "    vec4 texel = oe_splat_getTexel(cov.r*255.0, oe_splat_tc); \n"

        "    color = mix(color, texel, oe_splat_intensity*texel.a);\n"
        "} \n";
}

#endif // OSGEARTH_SPLAT_SHADERS