/* -*-c++-*- */
/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph
* Copyright 2008-2012 Pelican Mapping
* http://osgearth.org
*
* osgEarth is free software; you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>
*/
#ifndef OSGEARTH_SPLAT_NOISE_SHADERS
#define OSGEARTH_SPLAT_NOISE_SHADERS 1

#define NOISE_FUNC "oe_splat_noise"

#define MULTILINE(...) #__VA_ARGS__

namespace
{
const char* noise4Dshaders =

"    vec3 mod289(vec3 x) {\n"
"      return x - floor(x * (1.0 / 289.0)) * 289.0;\n"
"    }\n"
"\n"
"    vec2 mod289(vec2 x) {\n"
"      return x - floor(x * (1.0 / 289.0)) * 289.0;\n"
"    }\n"
"\n"
"    vec3 permute(vec3 x) {\n"
"      return mod289(((x*34.0)+1.0)*x);\n"
"    }\n"
"\n"
"    vec4 mod289(vec4 x) {\n"
"        return x - floor(x * (1.0 / 289.0)) * 289.0; }\n"
"\n"
"    float mod289(float x) {\n"
"        return x - floor(x * (1.0 / 289.0)) * 289.0; }\n"
"\n"
"    vec4 permute(vec4 x) {\n"
"        return mod289(((x*34.0)+1.0)*x);\n"
"    }\n"
"\n"
"    float permute(float x) {\n"
"        return mod289(((x*34.0)+1.0)*x);\n"
"    }\n"
"\n"
"    vec4 taylorInvSqrt(vec4 r) {\n"
"        return 1.79284291400159 - 0.85373472095314 * r;\n"
"    }\n"
"\n"
"    float taylorInvSqrt(float r) {\n"
"        return 1.79284291400159 - 0.85373472095314 * r;\n"
"    }\n"
"\n"
"    vec4 grad4(float j, vec4 ip)\n"
"    {\n"
"        const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n"
"        vec4 p,s;\n"
"\n"
"        p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n"
"        p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n"
"        s = vec4(lessThan(p, vec4(0.0)));\n"
"        p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n"
"\n"
"        return p;\n"
"    }\n"
"						\n"
"    // (sqrt(5) - 1)/4 = F4, used once below\n"
"    #define F4 0.309016994374947451\n"
"\n"
"    float snoise4(vec4 v)\n"
"    {\n"
"        const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n"
"                              0.276393202250021,  // 2 * G4\n"
"                              0.414589803375032,  // 3 * G4\n"
"                             -0.447213595499958); // -1 + 4 * G4\n"
"\n"
"        // First corner\n"
"        vec4 i  = floor(v + dot(v, vec4(F4)) );\n"
"        vec4 x0 = v -   i + dot(i, C.xxxx);\n"
"\n"
"        // Other corners\n"
"\n"
"        // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n"
"        vec4 i0;\n"
"        vec3 isX = step( x0.yzw, x0.xxx );\n"
"        vec3 isYZ = step( x0.zww, x0.yyz );\n"
"        //  i0.x = dot( isX, vec3( 1.0 ) );\n"
"        i0.x = isX.x + isX.y + isX.z;\n"
"        i0.yzw = 1.0 - isX;\n"
"        //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n"
"        i0.y += isYZ.x + isYZ.y;\n"
"        i0.zw += 1.0 - isYZ.xy;\n"
"        i0.z += isYZ.z;\n"
"        i0.w += 1.0 - isYZ.z;\n"
"\n"
"        // i0 now contains the unique values 0,1,2,3 in each channel\n"
"        vec4 i3 = clamp( i0, 0.0, 1.0 );\n"
"        vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n"
"        vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n"
"\n"
"        //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n"
"        //  x1 = x0 - i1  + 1.0 * C.xxxx\n"
"        //  x2 = x0 - i2  + 2.0 * C.xxxx\n"
"        //  x3 = x0 - i3  + 3.0 * C.xxxx\n"
"        //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n"
"        vec4 x1 = x0 - i1 + C.xxxx;\n"
"        vec4 x2 = x0 - i2 + C.yyyy;\n"
"        vec4 x3 = x0 - i3 + C.zzzz;\n"
"        vec4 x4 = x0 + C.wwww;\n"
"\n"
"        // Permutations\n"
"        i = mod289(i); \n"
"        float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n"
"        vec4 j1 = permute( permute( permute( permute (\n"
"                   i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n"
"                 + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n"
"                 + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n"
"                 + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n"
"\n"
"        // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n"
"        // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n"
"        vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n"
"\n"
"        vec4 p0 = grad4(j0,   ip);\n"
"        vec4 p1 = grad4(j1.x, ip);\n"
"        vec4 p2 = grad4(j1.y, ip);\n"
"        vec4 p3 = grad4(j1.z, ip);\n"
"        vec4 p4 = grad4(j1.w, ip);\n"
"\n"
"        // Normalise gradients\n"
"        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n"
"        p0 *= norm.x;\n"
"        p1 *= norm.y;\n"
"        p2 *= norm.z;\n"
"        p3 *= norm.w;\n"
"        p4 *= taylorInvSqrt(dot(p4,p4));\n"
"\n"
"        // Mix contributions from the five corners\n"
"        vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n"
"        vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n"
"        m0 = m0 * m0;\n"
"        m1 = m1 * m1;\n"
"        return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n"
"                      + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n"
"\n"
"    }\n"
"\n"
"    // circular repeating noise trick\n"
"    float oe_splat_noise_circle(in vec2 s)\n"
"    {\n"
"        const float twoPI = 6.2831853;\n"
"\n"
"        float x = cos(s.x*twoPI)/twoPI;\n"
"        float y = cos(s.y*twoPI)/twoPI;\n"
"        float z = sin(s.x*twoPI)/twoPI;\n"
"        float w = sin(s.y*twoPI)/twoPI;\n"
"\n"
"        return snoise4(vec4(x, y, z, w));\n"
"    }"



        "float oe_splat_noise2(vec2 v)\n"
        "{\n"
        "    const vec4 C = vec4(0.211324865405187,\n"  // (3.0-sqrt(3.0))/6.0
        "                        0.366025403784439,\n"  // 0.5*(sqrt(3.0)-1.0)
        "                       -0.577350269189626,\n"  // -1.0 + 2.0 * C.x
        "                        0.024390243902439);\n" // 1.0 / 41.0
        // First corner
        "    vec2 i  = floor(v + dot(v, C.yy) );\n"
        "    vec2 x0 = v -   i + dot(i, C.xx);\n"

        // Other corners
        "    vec2 i1;\n"
        "    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n"
        "    vec4 x12 = x0.xyxy + C.xxzz;\n"
        "    x12.xy -= i1;\n"

        // Permutations
        "    i = mod289(i);\n" // Avoid truncation effects in permutation
        "    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n"
        "              + i.x + vec3(0.0, i1.x, 1.0 ));\n"

        "    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n"
        "    m = m*m ;\n"
        "    m = m*m ;\n"

        // Gradients: 41 points uniformly over a line, mapped onto a diamond.
        // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)

        "    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n"
        "    vec3 h = abs(x) - 0.5;\n"
        "    vec3 ox = floor(x + 0.5);\n"
        "    vec3 a0 = x - ox;\n"

        // Normalise gradients implicitly by scaling m
        // Approximation of: m *= inversesqrt( a0*a0 + h*h )
        "    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n"

        // Compute final noise value at P
        "    vec3 g;\n"
        "    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n"
        "    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n"
        "    return 130.0 * dot(m, g);\n"
        "}\n"

        // Turbulence function
        "float oe_splat_turbulence(in vec2 seed, in float freq) {\n"
        "    float t = -0.5;\n"
        "    for(; freq<127.0; freq*=2.0) {\n"
        "        t += abs(oe_splat_noise2(seed/freq));\n"
        "    }\n"
        "    return t;\n"
        "}\n";

}

#endif // OSGEARTH_SPLAT_NOISE_SHADERS
