<!--
osgEarth Sample.

Shows how to use JavaScript to alter feature data.
This demo takes street centerlines and places streetlights along the 
side of the road, and rotates them to face the road.
-->

<map name="Boston Demo" type="geocentric" version="2">
    
    <image name="readymap_imagery" driver="tms">
        <url>http://readymap.org/readymap/tiles/1.0.0/22/</url>
    </image>
    
    <elevation name="readymap_elevation" driver="tms" enabled="false">
        <url>http://readymap.org/readymap/tiles/1.0.0/9/</url>
    </elevation>

	
	<!-- Positions streetlamps every 20m along the side of the roads. -->
    <model name="streetlamps" driver="feature_geom">

		<!-- Center lines. The resampling filter gives us the spacing we need. -->
        <features name="street centerlines" driver="ogr" build_spatial_index="true">
            <url>../data/boston-scl-utm19n-meters.shp</url>
			<resample min_length="20" max_length="20"/>
		</features>

        <layout tile_size_factor="5" crop_features="true">
            <level max_range="1000" style="default"/>
        </layout>
        
        <instancing>true</instancing>
        
        <styles>
            
			<!-- "model-script" runs for each feature. -->
            <style type="text/css">
                default {
                    model:             "../data/streetlight.osgb";
                    model-script:      positionAlongSegments();
					model-heading:     feature.properties.heading;
                    altitude-clamping: terrain;
                }
            </style>
            
			<!-- The object "feature" is available globally, and conforms to the GeoJSON standard. -->
            <script language="javascript">
              <![CDATA[
                
                offset = 4.0; // offset from road centerline (m)
              
			    // process all segments.
                function positionAlongSegments() {
                                                 
                    var output = [];
					feature.properties.heading = 0.0;
                    
                    if (feature.geometry.type == 'LineString') {
                        doLineString(feature, feature.geometry, output);                        
                    }
                    else if (feature.geometry.type == 'MultiLineString') {
                        var output = [];
                        for(var i=0; i<feature.geometry.coordinates.length; ++i) {
                            doLineString(feature, feature.geometry.coordinates[i], output);
                        }
                    }
                    
                    if ( output.length > 0 ) {
                        feature.geometry.type = 'MultiPoint';
                        feature.geometry.coordinates = output;
                        feature.save();
                    }
                }

				// process a single line string.
                function doLineString(feature, geom, output) {

                    for(i=0; i<geom.length-1; ++i) {
                    
                        var segment = { 
                            p0: geom[i], 
                            p1: geom[i+1]
                        };
						
						// midpoint of segment:
						var midpoint = {
							x: 0.5*(segment.p0[0] + segment.p1[0]),
							y: 0.5*(segment.p0[1] + segment.p1[1])
						};
                        
                        // directional vector of the road segment:
                        var vector = {
                            x: segment.p1[0] - segment.p0[0],
                            y: segment.p1[1] - segment.p0[1]
                        };
                        
                        // normalize the vector:
                        var veclen = Math.sqrt(vector.x*vector.x + vector.y*vector.y);
                        vector.x /= veclen;
                        vector.y /= veclen;
                        
                        // perpendicular vector:
                        var pvector = {
                            x: -vector.y,
                            y:  vector.x
                        };
                        
                        output.push( [
                            midpoint.x + offset*pvector.x,
                            midpoint.y + offset*pvector.y
                        ] );
                        
						/* other side (commented out sine we cannot rotate twice)
                        output.push( [
                            midpoint.x - offset*pvector.x,
                            midpoint.y - offset*pvector.y
                        ] );
						*/

						// rotate the model to face the street. 
						// caveat: only one 'heading' per feature!
						var angle = 90 + Math.atan2(pvector.y, pvector.x)*57.2958;
						if ( !isNaN(angle) ) {
							feature.properties.heading = angle;
						}
                    }
                }
              ]]>
            </script>
        </styles>   
    </model>
	
    
    <!-- Render the street themselves --->
    <model name="Streets" driver="feature_geom" enabled="true">
        <features name="streets" driver="ogr" build_spatial_index="true">
            <url>../data/boston-scl-utm19n-meters.shp</url>
			<resample min_length="20" max_length="20"/>
        </features>
        
        <layout crop_features="true" tile_size_factor="7.5">
            <level max_range="5000"/>
        </layout>
        
        <styles>
            <style type="text/css">
                streets {
                    stroke:                       #0000006f;
                    stroke-width:                 7.0m;
                    altitude-clamping:            terrain;
                    render-depth-offset-min-bias: 3.6;
                }
            </style>
        </styles>        
    </model>

	
	<!-- Simple buildings layer, for context. -->
    <model name="buildings" driver="feature_geom">
        <features name="buildings" driver="ogr">
            <url>../data/boston_buildings_utm19.shp</url>
            <build_spatial_index>true</build_spatial_index>
			<resample min_length="2.5"/>
        </features>
        <layout tile_size_factor="52">
            <level name="default" max_range="20000" style="buildings"/>
        </layout>
        <styles>             
            <style type="text/css">
                buildings {
                    extrusion-height:        3.5 * max([story_ht_], 1);
                    extrusion-flatten:       true;
					fill:                    #7f7f7f;
					stroke:                  #9f9f7f;
                    extrusion-wall-gradient: 0.2;
                    altitude-clamping:       terrain;
                }            
            </style>
        </styles>   
    </model>
    
    
    <external>
        <viewpoints>
            <viewpoint name="Boston Overview" heading="24.261" height="0" lat="42.34425" long="-71.076262" pitch="-21.6" range="3450"/>
            <viewpoint name="Boston Downtown 1" heading="117" lat="42.3568" long="-71.0585" height="0" pitch="-20.4" range="1500" />
            <viewpoint name="Boston Downtown 2" heading="-128.5" lat="42.3582" long="-71.0546" height="0" pitch="-19" range="1620" />
            <viewpoint name="Boston Street Level" heading="-145.85" lat="42.36460" long="-71.053612" pitch="-10.1" range="85.034"/>
        </viewpoints>
        <sky driver="simple" hours="14.0"/>
    </external>
  
</map>
